import("TFE_Core/Subscars/GlobalAbilities/Imports/GlobalAbilities_Imports.scar")

g_btn = ""

g_AllTrackedAbilityBuilders = {}
g_AllTrackedAbilityBuildersCount = 0
g_IsDoingAbility = false --This NEEDS to be changed later as part of an ability class

g_AllTrackedAbilities = {}
g_LastActivatedPlayer = nil
g_GlobalAbilityMods = {}


function Setup_GlobalAbilities()

	AddStacktrace("Setup_GlobalAbilities")
	
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Starting: 'Setup_GlobalAbilities'...")

	Setup_ActualGlobalAbilies()
	EventCue_DoEvent( 'warning', 'music/stinger_completeobjective', 'Global Abilities Activated!', 'Global Abilities Activated!.' )

	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Finished: 'Setup_GlobalAbilities'!")

	RemoveStacktrace()

end

function GetLocalPlayerStruct()

	AddStacktrace("GetLocalPlayerStruct")

	local localPlayerIndex = Tut_GetLocalPlayerIndex()
	local localPlayer = nil

	for i = 1, g_PlayerCount do

		if(g_AllPlayers[i].PlayerIndex == localPlayerIndex) then

			localPlayer = g_AllPlayers[i]
			break

		end

	end

	if(localPlayer == nil) then

		Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Local player does not exist!")

	end

	RemoveStacktrace()

	return localPlayer

end

function Setup_ActualGlobalAbilies()

	AddStacktrace("Setup_ActualGlobalAbilies")

	Dev_SetupAutoConstructor()

	local RaceName = ""
	for i = 1, g_PlayerCount do

		RaceName = g_AllPlayers[i].RaceDetails.RaceName
		local squadBP = "world_squad_global_ability_caster_"..RaceName
		
		if(SBP_Exists(squadBP)) then
			
			ActivateSummonSquadAbility(squadBP, g_AllPlayers[i].Player, g_AllPlayers[i].StartingPosition, 1)
		
		else

			Log(eLOG_LOG_TYPE_ERROR, eLOG_FULL, "Global Ability Caster SBP for race '"..RaceName.."' doesn't exist, make sure there is an entity called '"..GlobalAbilityCasterSBP.."' otherwise commander UI will be odd!")
		
		end


		--[[GENERIC]]
		AbilityStruct_GenericRetreatToBase = CreateGlobalAbility(
				"",
				i, 
				"Generic_Retreat_To_Base", 
				"generic_retreat_entity",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

		--Logic must be ended by the code not by the duration
		AbilityStruct_GenericRetreatToBase.TimedAbilityEndAfterDuration = false
			
		AbilityStruct_GenericRetreatToBase.AcceptedArmourTypes = 
		{
			"tp_commander", "tp_sub_commander", "tp_infantry_heavy_med", "tp_infantry_heavy_high",
			"tp_infantry_high", "tp_infantry_med", "tp_infantry_low"
		}

		AbilityStruct_GenericRetreatToBase.ModifiersToApplyOnRetreat = 
		{
			gMod_DisableShooting, gMod_DisableMelee, gMod_DisableMoraleRegen, gMod_MaxMoraleReduction100, gMod_DisableConstruction, 
			gMod_DisableAbilities, gMod_DisableAbilitiesUI, gMod_DisableControl, gMod_DisableTeleport, gMod_DisableReinforce,
			gMod_DisableUpgrades, gMod_MaxMorale00
		}

		AbilityStruct_GenericRetreatToBase.TrackedSquads = 
		{

		}

		AbilityStruct_GenericRetreatToBase.NumberOfTrackedSquads = 0

		AbilityStruct_GenericRetreatToBase.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

			local own, _, _, _ = GetAllPlayerRelationships(_self.CasterPlayer)				
			local SquadsWithAcceptedArmour = GetAllSquadsOfArmourTypeFromPlayerTable(own, _self.AcceptedArmourTypes, true)
			local ClosestSquad = GetClosestSquadInSquadTableToPos(SquadsWithAcceptedArmour, _pos, 100)
				
			if(ClosestSquad ~= nil) then

				if(World_DistancePointToPoint(ClosestSquad.SquadPosition, ClosestSquad.OwnerPlayer.StartingPosition) > 20) then

					_self.NumberOfTrackedSquads = _self.NumberOfTrackedSquads + 1
					_self.TrackedSquads[_self.NumberOfTrackedSquads] = { Squad = ClosestSquad, ModsApplied = false }

					print("adding entity ".._self.NumberOfTrackedSquads)

					if(_self.TimedAbilityIsActive == false) then
						
						_self:ActivateTimedAbility()

					end

				end
				
			end
			
		end

		--TODO: When a squad arrives shift to the left the data 
		AbilityStruct_GenericRetreatToBase.TimedAbilityUpdate = function(_self)
			
			for i = 0, _self.NumberOfTrackedSquads - 1 do
				print("Number of retreaters ".._self.NumberOfTrackedSquads)
				local index = _self.NumberOfTrackedSquads - i --_self.NumberOfTrackedSquads == 1 and 1 or _self.NumberOfTrackedSquads - i
				print("HI "..index)
				local squadStruct = _self.TrackedSquads[index]	

				if(squadStruct ~= nil) then

					local squad = squadStruct.Squad					

					if(squad ~= nil) then

						--Apply initial mods if not already applied
						if(ModsApplied == false) then
							print("APPLYING")
	
							for x = 1, TableLength(_self.ModifiersToApplyOnRetreat) do
			
								ModifierUtil_ApplyToSGroup(squad.SquadGroupID, _self.ModifiersToApplyOnRetreat[x], true)
			
							end
							
						end

						Command_SquadPos(squad.OwnedByPlayer, squad.SquadGroupID, SCMD_Move, squad.OwnerPlayer.StartingPosition)

						if(World_DistancePointToPoint(squad.SquadPosition, squad.OwnerPlayer.StartingPosition) <= 20) then

							print("REMOVING!")
							for x = 1, TableLength(_self.ModifiersToApplyOnRetreat) do

								ModifierUtil_ApplyToSGroup(squad.SquadGroupID, _self.ModifiersToApplyOnRetreat[x], false)

							end

							_self.RemoveSquadEntryAtIndex(_self, index)
							break --Needed?

						end

					else						

						_self.RemoveSquadEntryAtIndex(_self, index)
						break --Needed?

					end

				else

					print("SQAUD STURCT IT NULL")

				end

			end

			if(_self.NumberOfTrackedSquads == 0) then

				print("retreat ability end")
				_self.TimedAbilityIsActive = false

			end

		end

		AbilityStruct_GenericRetreatToBase.RemoveSquadEntryAtIndex = function(_self, _index)

			_self.NumberOfTrackedSquads = _self.NumberOfTrackedSquads - 1
			--_self.TrackedSquads[index] = nil
			TableShiftLeftAfterIndex(_self.TrackedSquads, _index)

		end


		--[[CHAOS]]
		if(RaceName == "chaos_marine_race") then
			
			--[[NON GLOBALS]]
			AbilityStruct_ChaosSorcererTeleportationNodes = CreateGlobalAbility(
				"",
				i, 
				"Chaos_Sorcerer_Teleportation_Nodes", 
				"chaos_sorcerer_teleportation_node_entity",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
			
			AbilityStruct_ChaosSorcererTeleportationNodes.DelayBeforeSorcererPortal = 2
			AbilityStruct_ChaosSorcererTeleportationNodes.TeleportationNodeArea = 7
			AbilityStruct_ChaosSorcererTeleportationNodes.TeleportSetupTime = 2 --[[To be implemented, time the units need to be in portal before they can TP]]
			AbilityStruct_ChaosSorcererTeleportationNodes.TeleportTravelTime = 3 --[[To be implemented, time it takes to travel from 1 portal to another]]
			AbilityStruct_ChaosSorcererTeleportationNodes.Duration = 60
			AbilityStruct_ChaosSorcererTeleportationNodes.BlacklistedSquadsFromNode = {}
			AbilityStruct_ChaosSorcererTeleportationNodes.SquadsPreparingForTeleport = {}
			AbilityStruct_ChaosSorcererTeleportationNodes.SquadsInTransit = {}
			AbilityStruct_ChaosSorcererTeleportationNodes.LoopingFX = {}
			AbilityStruct_ChaosSorcererTeleportationNodes.AcceptedArmourTypes = 
			{
				"tp_builder", "tp_commander", "tp_infantry_heavy_med", "tp_infantry_heavy_high",
				"tp_infantry_high", "tp_infantry_med", "tp_infantry_low", "tp_monster_med"
			}
			AbilityStruct_ChaosSorcererTeleportationNodes.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				_self.targetPos = World_Pos(_pos.x, _pos.y, _pos.z)
				
				_self.ActivatedTime = g_WorldTime	
				_self:ResetAbility()		
				_self:ActivateTimedAbility()

			end

			AbilityStruct_ChaosSorcererTeleportationNodes.TimedAbilityUpdate = function(_self)

				if(_self.BothNodesActivated == false) then

					if(g_WorldTime - _self.ActivatedTime >= _self.DelayBeforeSorcererPortal) then
						
						local CastingSorcerers = GetAllSquadsOfBlueprint(_self.CasterPlayerIndex, {"chaos_squad_sorcerer"})

						if(TableLength(CastingSorcerers) == 0) then
							
							_self.TimedAbilityIsActive = false
							_self.TimedAbilityEnd()

						else

							_self.BothNodesActivated = true
							_self.StartNodePosition = CastingSorcerers[1].SquadPosition
							_self.BlacklistedSquadsFromNode[1] = 
							{ 
								Squad = CastingSorcerers[1], 
								Node = _self.StartNodePosition 
							}

							table.insert(_self.LoopingFX, World_FXEventLooping( "data:Art/Events/races/chaos/chaos_global_active_glow", _self.StartNodePosition ))
							table.insert(_self.LoopingFX, World_FXEventLooping( "data:Art/Events/races/chaos/chaos_global_active_glow", _self.targetPos ))
							
						end

					end
					
				else

					local tmpNewBlacklistedSquads = {}
					for i = 1, TableLength(_self.BlacklistedSquadsFromNode) do

						--If blacklisted squads have left the teleportation node then we can allow them to re-enter it
						if(World_DistancePointToPoint(_self.BlacklistedSquadsFromNode[i].Squad.SquadPosition, _self.BlacklistedSquadsFromNode[i].Node) <= _self.TeleportationNodeArea + 1.75) then

							table.insert(tmpNewBlacklistedSquads, _self.BlacklistedSquadsFromNode[i])
						
						end

					end

					_self.BlacklistedSquadsFromNode = tmpNewBlacklistedSquads

					local PlayerSquadsInAreaOfNodes = { StartNode = {}, EndNode = {} }
					PlayerSquadsInAreaOfNodes.StartNode = GetAllSquadsInArea_NonPlayerSpecific(_self.StartNodePosition, _self.TeleportationNodeArea)
					PlayerSquadsInAreaOfNodes.EndNode = GetAllSquadsInArea_NonPlayerSpecific(_self.targetPos, _self.TeleportationNodeArea)

					--PlayerSquadsInAreaOfNodes.StartNode = GetAllSquadsOfArmourTypeFromSquadTable(PlayerSquadsInAreaOfNodes.StartNode, _self.AcceptedArmourTypes)
					--PlayerSquadsInAreaOfNodes.EndNode = GetAllSquadsOfArmourTypeFromSquadTable(PlayerSquadsInAreaOfNodes.EndNode, _self.AcceptedArmourTypes)
					
					PlayerSquadsInAreaOfNodes.StartNode = _self:RemoveBlacklistedSquads(PlayerSquadsInAreaOfNodes.StartNode)
					PlayerSquadsInAreaOfNodes.EndNode = _self:RemoveBlacklistedSquads(PlayerSquadsInAreaOfNodes.EndNode)

					for y = 1, TableLength(PlayerSquadsInAreaOfNodes.EndNode) do

						if PlayerSquadsInAreaOfNodes.EndNode[y] ~= nil then

							if PlayerSquadsInAreaOfNodes.EndNode[y].SquadUniqueID ~= nil then

								_self:StartTeleport(PlayerSquadsInAreaOfNodes.EndNode[y])
								_self:EndTeleport(PlayerSquadsInAreaOfNodes.EndNode[y], _self.StartNodePosition)
								
								PlayerSquadsInAreaOfNodes.EndNode[y] = nil

							end

						end

					end

					for z = 1, TableLength(PlayerSquadsInAreaOfNodes.StartNode) do
						
						if PlayerSquadsInAreaOfNodes.StartNode[z] ~= nil then

							if PlayerSquadsInAreaOfNodes.StartNode[z].SquadUniqueID ~= nil then

								_self:StartTeleport(PlayerSquadsInAreaOfNodes.StartNode[z])
								_self:EndTeleport(PlayerSquadsInAreaOfNodes.StartNode[z], _self.targetPos)

								PlayerSquadsInAreaOfNodes.StartNode[z] = nil

							end

						end

					end

				end

			end

			AbilityStruct_ChaosSorcererTeleportationNodes.RemoveBlacklistedSquads = function( _self, _squadsArray )
				
				local ReturnArray = {}
				for squadPos = 1, TableLength(_squadsArray) do	

					local IsBlacklisted = false
					for blacklistedSquadPos = 1, TableLength(_self.BlacklistedSquadsFromNode) do	
						
						if(_squadsArray[squadPos] == _self.BlacklistedSquadsFromNode[blacklistedSquadPos].Squad) then
							
							IsBlacklisted = true

						end							

					end

					if(IsBlacklisted == false) then
						
						table.insert(ReturnArray, _squadsArray[squadPos])

					end
				
				end

				return ReturnArray

			end

			AbilityStruct_ChaosSorcererTeleportationNodes.StartTeleport = function( _self, _targetSquad )

				World_FXEventSquad( "data:Art/Events/Unit_Upgrade_Morale_FX/Reinforce_Trooper", _targetSquad.SquadGroupID )
				SGroup_DeSpawn(_targetSquad.SquadGroupName)

			end

			AbilityStruct_ChaosSorcererTeleportationNodes.EndTeleport = function( _self, _targetSquad, _targetNodePosition )

				SGroup_ReSpawnPosition(_targetSquad.SquadGroupName, _targetNodePosition)
				Cmd_AttackMovePos( _targetSquad.SquadGroupName, _targetNodePosition )
				World_FXEventSquad( "data:Art/Events/Unit_Upgrade_Morale_FX/Reinforce_Trooper", _targetSquad.SquadGroupID )
				table.insert(_self.BlacklistedSquadsFromNode, { Squad = _targetSquad, Node = _targetNodePosition } )

			end

			AbilityStruct_ChaosSorcererTeleportationNodes.TimedAbilityEnd = function( _self )

				_self:ResetAbility()
				
			end

			AbilityStruct_ChaosSorcererTeleportationNodes.ResetAbility = function(_self)

				_self.StartNodePosition = nil
				_self.BothNodesActivated = false
				_self.BlacklistedSquadsFromNode = {}

				for i = 1, TableLength(_self.LoopingFX) do

					World_FXEventDestroy(_self.LoopingFX[i])

				end
				
				_self.LoopingFX = {}

			end

			--[[GLOBALS]]
			local AbilityStruct_ChaosMarines1 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_ChaosMarines2 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_ChaosMarines3 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_ChaosMarines4 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_ChaosMarines5 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
			--T0 Secret Identity 
			--T0 Target a squad and it gets infiltrated, possibly get some small extra benefits 
			--Sigyl of the Rift to send it to the HQ? Or to transport between 2 locations? Perhaps ability for the Sorcerer?
			--T1 Return to HQ
			--T2 Target an area, spawn a rot fly that has number = to the number of bloodsplats in the area and destroy those bloodsplats. bloodsplats near the rot fly will add another member to the squad or spawn another squad?..
			--T2 Boon of chaos. applies boon of chaos based on what's happening in AoE. khorne for combat, nurgle for healing, slaanesh for neutral, tzeentch random
			--T3 Nuke 8 pointed star that damages out from the centre with KB. while active lighting randomly spawns in the circle, rocks spawn at the ends that are owned by the world or player?

		--[[DARK ELDAR GLOBALS]]
		elseif(RaceName == "dark_eldar_race") then
			
			local AbilityStruct_DarkEldar1 = CreateGlobalAbility(
				squadBP.."_seed_souls",
				i, 
				"GlobalAbility_DarkEldar_SeedSouls", 
				"global_dark_eldar_seed_souls_entity",
				"TARGETED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_DarkEldar2 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_DarkEldar3 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_DarkEldar4 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_DarkEldar5 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_DarkEldar1.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				_pos = _self.LastCastedEntityPosition

				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-30, -100))

				if(costSuccess) then

					World_FXEvent("data:Art/Events/Races/dark_eldar/Ability/dark_eldar_global_seed_soul", _pos)
					ActivateMultiSummonSquadAbility("dark_eldar_squad_slave_murdered_long", _self.CasterPlayer.Player, _pos, {x = 1, y = 0, z = 1}, 5, 0, 0)
				
				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				
				end

			end
			
			--[[T1 Target captured point without an lp, steal 100req and decap it. vs necron you steal 50 power]]
			--[[T2 Foul Experiment Target an area, all souls in that area get destroyed and summon a zombie. zombie is tanky but looses HP over time, uncontrollable. if no souls are there, summon 3 zombies. zombie has no ui]]
			--[[T2 Every vehicle currently alive and hellions gets a forcefield]]
			--[[T3 Recharge all soul abilities instantly, gain 150 souls]]

			--^Should 1 of these be more overtly aggressive?

		--[[ELDAR GLOBALS]]
		elseif(RaceName == "eldar_race") then

			--Global 1		--WE NEED TO MAKE THIS MAKE A SOUND FOR ALL PLAYERS TO HEAR
			local AbilityStruct_Eldar1 = CreateGlobalAbility(
				squadBP.."_webway_gate",
				i, 
				"GlobalAbility_Eldar_SummonWebwayGate", 
				"global_eldar_summon_webway_gate_entity",
				"TARGETED",
				"GROUND",
				table.getn(g_AllTrackedAbilities)
			)
			
			local AbilityStruct_Eldar2 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
			
			local AbilityStruct_Eldar3 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
			
			local AbilityStruct_Eldar4 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
			
			local AbilityStruct_Eldar5 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_Eldar1.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				_pos = _self.LastCastedEntityPosition

				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-30, -100))

				if(costSuccess) then

					ActivateAutoConstructionAbility(_pos, _self.CasterPlayer, "eldar_webway_gate")

				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")

				end
				
			end
		
			--[[T1 Swift movement, all troops including allies get 20% speed bonus]]
			--[[T2 Summon squad of wraithguard near a webway gate]]
			--[[T2 Target area, all enemy squads get full silenced (remove all buffs from code and reset their modifiers) and silence them for 60s]]
			--[[T3
				Unique inspire for all units that provide special buffs depending on which it is
					Ranger reload time 
					Farseer & warlock ability cooldown
					Guardian damage resistance
					Dark reaper setup time to 0 
					Fire dragons small range increase and dmg increase
					Warp spiders really fast teleport cooldown
					Seer council reinforce time decrease
					Fire Prism reload time
					Wraithlord bunch of healing
					Falcon teleport time
					Nightwing & platforms & vypers speed up
					Turrets reload time
					Avatar slight damage resist?
				 ^- maybe change this as neron global for thermo felt bad]]

		--[[NECRON GLOBALS]]
		elseif(RaceName == "necron_race") then	
			
			mod_NecronProductionOverload__modifier_01 = Modifier_Create(MAT_EntityType, "production_speed_modifier", MUT_Multiplication, 1, 3, "monolith")
			table.insert(g_GlobalAbilityMods, mod_NecronProductionOverload__modifier_01)
			mod_NecronProductionOverload__modifier_02 = Modifier_Create(MAT_EntityType, "production_speed_modifier", MUT_Multiplication, 1, 3, "necron_restored_monolith")
			table.insert(g_GlobalAbilityMods, mod_NecronProductionOverload__modifier_02)
			mod_NecronProductionOverload__modifier_03 = Modifier_Create(MAT_Player, "income_power_player_modifier", MUT_Multiplication, 1, 0.5, "")
			table.insert(g_GlobalAbilityMods, mod_NecronProductionOverload__modifier_03)

			
			mod_NecronEternalMarch__modifier_01 = Modifier_Create(MAT_Squad, "health_get_back_up_modifier", MUT_Multiplication, 1, 1000, "")
			table.insert(g_GlobalAbilityMods, mod_NecronEternalMarch__modifier_01)


			--[[Non race specific]]
			AbilityStruct_NecronCryptekSummonScarabOnHit = CreateGlobalAbility(
				"Necron_Cryptek_Summon_Scarab_On_Hit",
				i, 
				"Necron_CryptekSummonScarabOnHit", 
				"necron_cryptek_summon_scarab_entity",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
					
			AbilityStruct_NecronCryptekSummonScarabOnHit.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )
				
				_pos = _self.LastCastedEntityPosition
				ActivateSummonSquadAbility("necron_scarab_ground_squad", g_AllPlayers[i].Player, _pos, 1)

			end

			local AbilityStruct_Necron1 = CreateGlobalAbility(
				squadBP.."_production_overload",
				i, 
				"GlobalAbility_Necron_ProductionOverload", 
				"global_necron_production_overload_entity",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Necron2 = CreateGlobalAbility(
				squadBP.."_summon_obelisk",
				i, 
				"GlobalAbility_Necron_SummonObelisk", 
				"global_necron_summon_obelisk_entity",
				"TARGETED",
				"GROUND",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Necron3 = CreateGlobalAbility(
				squadBP.."_scarab_swarm",
				i, 
				"GlobalAbility_Necron_ScarabSwarm", 
				"global_necron_scarab_swarm_entity",
				"TARGETED",
				"GROUND",
				table.getn(g_AllTrackedAbilities)
			)	
			
			local AbilityStruct_Necron4 = CreateGlobalAbility(
				squadBP.."_thermo_overcharge",
				i, 
				"GlobalAbility_Necron_ThermoOvercharge", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)	
			
			local AbilityStruct_Necron5 = CreateGlobalAbility(
				squadBP.."_eternal_march",
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local BasicAbilityStruct_NecronReverseTime = CreateGlobalAbility(
				squadBP.."_reverse_time_AoE",
				i, 
				"BasicGlobalAbility_Reverse_Time_AoE", 
				"global_necron_reverse_time_aoe",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local BasicAbilityStruct_NecronReverseTimeShort = CreateGlobalAbility(
				squadBP.."_reverse_time_AoE_Short",
				i, 
				"BasicGlobalAbility_Reverse_Time_AoE_Short", 
				"global_necron_reverse_time_aoe_short",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local function ReverseTimeSingleSquad(_self, _EntityPos, _CastingPlayer)

				print(_CastingPlayer.PlayerIndex+1)
				local squadInArea = GetClosestSquadToPos(_CastingPlayer.PlayerIndex+1, _EntityPos, 5)
				local detachedSquadsData = {}

				--Firstly detach squad leaders
				local detachSuccess = pcall(Squad_Detach, squadInArea.SquadID )

				if detachSuccess then

					--Now that we've detached, we must reaffirm all the squad details to help identify the detached leader
					--We should find a way to do this more efficiently but for now this works
					Log(eLOG_TYPE_WARNING, eLOG_VERBOSE, "Resetting squad data somewhere other than SquadManager_Core. This goes against code design and should be changed before release.")
					Set_AllSquads_Immediate()

				end

				--Get again as we've now detached squad leaders
				squadInArea = GetClosestSquadToPos(_CastingPlayer.PlayerIndex+1, _EntityPos, 5)

				--Now send everyone back in time!				
				squadInArea:GoBackInTime(_self.ReverseTimeAmmount)


			end

			local function ReverseTimeInAoE(_self, _EntityPos)

				local squadsInArea = GetAllSquadsInArea_NonPlayerSpecific(_EntityPos, _self.Radius)
				local hasDetachedLeaders = false
				local detachedSquadsData = {}

				--Firstly detach squad leaders
				for i in squadsInArea do

					local detachSuccess = pcall(Squad_Detach, squadsInArea[i].SquadID )
					hasDetachedLeaders = hasDetachedLeaders or detachSuccess

				end

				if hasDetachedLeaders then

					--Now that we've detached, we must reaffirm all the squad details to help identify the detached leader
					--We should find a way to do this more efficiently but for now this works
					Log(eLOG_TYPE_WARNING, eLOG_VERBOSE, "Resetting squad data somewhere other than SquadManager_Core. This goes against code design and should be changed before release.")
					Set_AllSquads_Immediate()

				end

				--Get again as we've now detached squad leaders
				squadsInArea = GetAllSquadsInArea_NonPlayerSpecific(_EntityPos, _self.Radius)

				--Now send everyone back in time!
				for i in squadsInArea do

					squadsInArea[i]:GoBackInTime(_self.ReverseTimeAmmount)

				end

			end

			BasicAbilityStruct_NecronReverseTimeShort.ReverseTimeAmmount = 15
			BasicAbilityStruct_NecronReverseTimeShort.DoAbility = function(_self, _EntityPos)
				
				ReverseTimeSingleSquad(_self, _EntityPos, _self.CasterPlayer)			

			end

			BasicAbilityStruct_NecronReverseTime.Radius = 15
			BasicAbilityStruct_NecronReverseTime.ReverseTimeAmmount = 30
			BasicAbilityStruct_NecronReverseTime.DoAbility = function(_self, _EntityPos)
				
				ReverseTimeInAoE(_self, _EntityPos)				

			end

			

			AbilityStruct_Necron1.ApplyMonolithFX = function(_self, _EntityPos)
				
				local _MonolithEntity = EntityData[_self.CasterPlayer.PlayerIndex+1][_EntityPos]
				
				local FX = World_FXEvent("data:Art/Events/races/necron/abilities/monolith_production_boost", _MonolithEntity.EntityPosition)
				local tmpEntry = 
				{
					Entity = _MonolithEntity,
					FX = FX
				}

				table.insert(_self.AllMonolithFX, tmpEntry)
				
			end

			AbilityStruct_Necron1.RemoveMonolithFX = function(_self, _posToRemove)

				World_FXEventDestroy(_self.AllMonolithFX[_posToRemove].FX)
				table.remove(_self.AllMonolithFX, _posToRemove)

			end

			AbilityStruct_Necron1.Duration = 3 --25
			AbilityStruct_Necron1.AllMonolithFX = {}
			AbilityStruct_Necron1.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				_self.AppliedModifierIDs = {}
				_self.AllMonolithFX = {}
				_pos = _self.LastCastedEntityPosition

				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-30))

				if(costSuccess) then

					ActivateSummonEntityAbility("necron_production_overload_ability_caster", _self.CasterPlayer.Player, _pos)	

				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")

				end

			end

			AbilityStruct_Necron1.TimedAbilityEnd = function( _self )

				for i = 1, table.getn(_self.AppliedModifierIDs) do

					Modifier_Remove(_self.AppliedModifierIDs[i])

				end

				for j = 1, table.getn(_self.AllMonolithFX) do

					_self.RemoveMonolithFX(_self, j)

				end
				
			end
			
			AbilityStruct_Necron1.TimedAbilityUpdate = function(_self)

				for i = 1, table.getn(_self.AllMonolithFX) do

					if(Entity_Exists(_self.AllMonolithFX[i].Entity.EntityID) == false ) then
						
						_self:RemoveMonolithFX(_self, i)

					end

				end

				local AllMonolithEntities, AllMonolithEntities_Index = Get_EntityDataFromEntityBP("monolith", _self.CasterPlayer.PlayerIndex + 1)
				local AllRestoredMonolithEntities, AllRestoredMonolithEntities_Index = Get_EntityDataFromEntityBP("necron_restored_monolith", _self.CasterPlayer.PlayerIndex + 1)
				local newTable = {AllMonolithEntities_Index, AllRestoredMonolithEntities_Index}
				local AllEntitiesIndex = TableMerge(newTable)
				newTable = {AllMonolithEntities, AllRestoredMonolithEntities}
				local AllEntities = TableMerge(newTable)

				for i = 1, TableLength(AllEntitiesIndex) do

					local MonolithFXAlreadyApplied = false
					for j = 1, TableLength(_self.AllMonolithFX) do

						if(_self.AllMonolithFX[j].Entity == AllEntities[i]) then
							
							MonolithFXAlreadyApplied = true

						end

					end

					if(MonolithFXAlreadyApplied == false) then
						Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "APPLYING FX!")
						--Not working???
						--_self:ApplyMonolithFX(_self, AllEntitiesIndex[i])

					end
				end

				Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "TimedAbilityUpdate ability done")

			end


			AbilityStruct_Necron2.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )
				
				_pos = _self.LastCastedEntityPosition

				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-50))

				if(costSuccess) then

					ActivateSummonEntityAbility("necron_summon_obelisk", _self.CasterPlayer.Player, _pos)				

				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")

				end

			end

			
			AbilityStruct_Necron3.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )
				
				_pos = _self.LastCastedEntityPosition

				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-150))

				if(costSuccess) then

					ActivateMultiSummonSquadAbility("necron_scarab_ground_squad", _self.CasterPlayer.Player, _pos, {x = 1, y = 0, z = 1}, 3, 6, 9)		

				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				
				end

			end

			AbilityStruct_Necron4.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )
				

				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-150))

				if(costSuccess) then

					Cmd_CastAbilitySelf(_self.LinkedSquadGroupName, "necron_thermo_overcharge")	

				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				
				end

			end

			AbilityStruct_Necron5.Duration = 40
			AbilityStruct_Necron5.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )				

				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-300))

				if(costSuccess) then

					_self.ActivatedTime = g_WorldTime
					_self:ActivateTimedAbility()

				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				
				end

			end	
			
			AbilityStruct_Necron5.TimedAbilityUpdate = function(_self)

				local CasterPlayerIndex = _self.CasterPlayer.PlayerIndex + 1
				for i = 1, g_PlayerSquadCount[CasterPlayerIndex] do

					if(Squad_Exists(g_AllSquadsData[CasterPlayerIndex][i].SquadUniqueID) == true ) then

						if(ModifierUtil_GetSquadApplierIndex(mod_NecronEternalMarch__modifier_01, g_AllSquadsData[CasterPlayerIndex][i].SquadID) == 0) then
							
							local modID_01 = ModifierUtil_ApplyToSGroup(g_AllSquadsData[CasterPlayerIndex][i].SquadGroupID, mod_NecronEternalMarch__modifier_01, true)
							table.insert(_self.AppliedModifierIDs, modID_01)

						end

					end

				end

			end

			AbilityStruct_Necron5.TimedAbilityEnd = function( _self )

				local CasterPlayerIndex = _self.CasterPlayer.PlayerIndex + 1
				for i = 1, g_PlayerSquadCount[CasterPlayerIndex] do

					if(Squad_Exists(g_AllSquadsData[CasterPlayerIndex][i].SquadUniqueID) == true ) then

						if(ModifierUtil_GetSquadApplierIndex(mod_NecronEternalMarch__modifier_01, g_AllSquadsData[CasterPlayerIndex][i].SquadID) ~= 0) then
							
							ModifierUtil_ApplyToSGroup(g_AllSquadsData[CasterPlayerIndex][i].SquadGroupID, mod_NecronEternalMarch__modifier_01, false)

						end

					end

				end

				_self.AppliedModifierIDs = {}

			end
			--[[T0 Production Overload]]
			--[[T1 Summon crystal]] 
			--[[T2 Time Rift: Slowly revert all structures in the area back to their original construction state. Afterwards they start recbuilding themselves. Cannot affect HQ]]
			--[[T2 Big gen ability to buff all necron <- this needs to be changed later]]
			--[[T2 Summon a bunch of basic scarabs at target location]]
			--[[T3 All troops have 100% revive chance including wraith and tomb spyder]]

		--[[ORK GLOBALS]]
		elseif(RaceName == "ork_race") then	

			local AbilityStruct_Ork1 = CreateGlobalAbility(
				squadBP,
				i, 
				"GlobalAbility_Ork_ProductionCostReduction", 
				"global_ork_production_cost_reduction_entity",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_Ork1.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )
				
				_pos = _self.LastCastedEntityPosition

				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-30))

				if(costSuccess) then

					ActivateSummonEntityAbility("ork_production_cost_reduction_ability_caster", _self.CasterPlayer.Player, _pos)
				
				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				
				end

			end

			local AbilityStruct_Ork2 = CreateGlobalAbility(
				squadBP,
				i, 
				"GlobalAbility_Ork_UseYourChoppasAndDakka", 
				"global_ork_use_your_choppas_and_dakka_entity",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			mod_UseYourDakkaAndChoppa_Ranged__modifier_01 = Modifier_Create(MAT_Squad, "accuracy_ranged_weapon_modifier", MUT_Multiplication, 1, 1.15, "")
			table.insert(g_GlobalAbilityMods, mod_UseYourDakkaAndChoppa_Ranged__modifier_01)
			mod_UseYourDakkaAndChoppa_Ranged__modifier_02 = Modifier_Create(MAT_Squad, "reload_time_weapon_modifier", MUT_Multiplication, 1, 0.7, "")
			table.insert(g_GlobalAbilityMods, mod_UseYourDakkaAndChoppa_Ranged__modifier_02)

			mod_UseYourDakkaAndChoppa_Melee__modifier_01 = Modifier_Create(MAT_Squad, "max_damage_weapon_modifier", MUT_Multiplication, 1, 1.4, "")
			table.insert(g_GlobalAbilityMods, mod_UseYourDakkaAndChoppa_Melee__modifier_01)
			mod_UseYourDakkaAndChoppa_Melee__modifier_02 = Modifier_Create(MAT_Squad, "min_damage_weapon_modifier", MUT_Multiplication, 1, 1.2, "")
			table.insert(g_GlobalAbilityMods, mod_UseYourDakkaAndChoppa_Melee__modifier_02)
			mod_UseYourDakkaAndChoppa_Melee__modifier_03 = Modifier_Create(MAT_Squad, "health_meleedamage_received_modifier", MUT_Multiplication, 1, 0.8, "")
			table.insert(g_GlobalAbilityMods, mod_UseYourDakkaAndChoppa_Melee__modifier_03)
			mod_UseYourDakkaAndChoppa_Melee__modifier_04 = Modifier_Create(MAT_Squad, "special_attack_physics_mass", MUT_Multiplication, 1, 1.15, "")
			table.insert(g_GlobalAbilityMods, mod_UseYourDakkaAndChoppa_Melee__modifier_04)

			mod_UseYourDakkaAndChoppa_Generic__modifier_01 = Modifier_Create(MAT_Squad, "morale_rate_squad_modifier", MUT_Multiplication, 1, 1.4, "")
			table.insert(g_GlobalAbilityMods, mod_UseYourDakkaAndChoppa_Generic__modifier_01)
			modFX_UseYourDakkaAndChoppa_Generic__modifier_01 = Modifier_Create(MAT_Squad, "ability_fighting_juice_event", MUT_Enable, 1, 1, "")	
			table.insert(g_GlobalAbilityMods, modFX_UseYourDakkaAndChoppa_Generic__modifier_01)


			AbilityStruct_Ork2.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				_pos = _self.LastCastedEntityPosition

				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-50))
				if(costSuccess) then
					local AcceptedArmourTypes = {"tp_commander", "tp_infantry_heavy_med", "tp_infantry_heavy_high", "tp_infantry_med", "tp_infantry_high" }
					local RangedUnits = {"ork_flash_gitz_squad", "ork_squad_burnaboy", "ork_squad_shoota_boy", "ork_squad_tankbusta"}
					local MeleeUnits = {"ork_squad_armored_nob", "ork_squad_bad_dok", "ork_squad_feral_boy", "ork_squad_mek_boy", "ork_squad_nob", "ork_squad_slugga", "ork_squad_stikkbomba", "ork_squad_stormboy", "ork_squad_warboss" }
					local own, allies, _, _ = GetAllPlayerRelationships(_self.CasterPlayer)		
					allies = TableMerge({allies, own})		
					local SquadsWithAcceptedArmour = GetAllSquadsOfArmourTypeFromPlayerTable(own, AcceptedArmourTypes, true)
					local ClosestSquad = GetClosestSquadInSquadTableToPos(SquadsWithAcceptedArmour, _pos, 10)
					
					if(ClosestSquad ~= nil) then
						World_FXEvent("data:Art/Events/Races/Space_Marines/Abilities/space_marine_global_basic_scan", _pos)
						
						_self.TargetSquad = ClosestSquad
						local targetBP = _self.TargetSquad.SquadBlueprint
						if(TableContains(RangedUnits, targetBP)) then
							
							_self.TargetSquadAttackType = "RANGED"
						
						elseif(TableContains(MeleeUnits, targetBP)) then
							
							_self.TargetSquadAttackType = "MELEE"
						
						else					
							
							Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to determine if troop is a melee or ranged troop! Ensure SquadBP '"..targetBP.."' is present in code. Randomly assigning between melee or range.")		
							
							if(World_GetRand(0,100) > 50) then
								
								_self.TargetSquadAttackType = "RANGED"
							
							else
								
								_self.TargetSquadAttackType = "MELEE"
							
							end

						end

						_self.Duration = 20
						_self.FX_RefireRate = 0.1
						_self.FX_LastFireTime = 0
						_self.FX_Table = {}
						_self.AppliedMods = {}

						if(_self.TargetSquadAttackType == "RANGED") then
							
							table.insert(_self.AppliedMods, Modifier_ApplyToSquad(mod_UseYourDakkaAndChoppa_Ranged__modifier_01, _self.TargetSquad.SquadID))
							table.insert(_self.AppliedMods, Modifier_ApplyToSquad(mod_UseYourDakkaAndChoppa_Ranged__modifier_02, _self.TargetSquad.SquadID))

						elseif(_self.TargetSquadAttackType == "MELEE") then
							
							table.insert(_self.AppliedMods, Modifier_ApplyToSquad(mod_UseYourDakkaAndChoppa_Melee__modifier_01, _self.TargetSquad.SquadID))
							table.insert(_self.AppliedMods, Modifier_ApplyToSquad(mod_UseYourDakkaAndChoppa_Melee__modifier_02, _self.TargetSquad.SquadID))
							table.insert(_self.AppliedMods, Modifier_ApplyToSquad(mod_UseYourDakkaAndChoppa_Melee__modifier_03, _self.TargetSquad.SquadID))
							table.insert(_self.AppliedMods, Modifier_ApplyToSquad(mod_UseYourDakkaAndChoppa_Melee__modifier_04, _self.TargetSquad.SquadID))
						
						end

						table.insert(_self.AppliedMods, Modifier_ApplyToSquad(mod_UseYourDakkaAndChoppa_Generic__modifier_01, _self.TargetSquad.SquadID))
						table.insert(_self.AppliedMods, Modifier_ApplyToSquad(modFX_UseYourDakkaAndChoppa_Generic__modifier_01, _self.TargetSquad.SquadID))
						
						_self.ActivatedTime = g_WorldTime
						_self:ActivateTimedAbility()
					
					else

						Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to no targets in area.")
					
					end

				else
					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				end
			end

			AbilityStruct_Ork2.TimedAbilityEnd = function( _self )
				
				for i = 1, TableLength(_self.FX_Table) do
					World_FXEventDestroy(_self.FX_Table[i])
				end
				
				for i = 1, TableLength(_self.AppliedMods) do
					if(_self.AppliedMods[i] ~= nil) then
						if(Modifier_Exists(_self.AppliedMods[i])) then
							pcall(Modifier_Remove, _self.AppliedMods[i])
						end
					end
				end
			end
			

			local AbilityStruct_Ork3 = CreateGlobalAbility(
				squadBP,
				i, 
				"GlobalAbility_Ork_FeralBoyz", 
				"global_ork_feral_boyz_entity",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_Ork3.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )
				
				_pos = _self.LastCastedEntityPosition

				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-150))

				if(costSuccess) then

					local squadIDs = ActivateMultiSummonSquadAbility("ork_squad_feral_boy", _self.CasterPlayer.Player, _pos, {x = 1, y = 0, z = 1}, 3, 9, 9)
					local SGroupID = GetUniqueSG("GlobalAbility_FeralBoyzSummoned")
					local SGroupName = SGroup_GetName(SGroupID)
					for i = 1, TableLength(squadIDs) do
						SGroup_Add(SGroupID, squadIDs[i])
					end

					Cmd_CastAbilitySelf(SGroupName, "ork_waaagh_infantry_noicon")

				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				
				end

			end

			local AbilityStruct_Ork4 = CreateGlobalAbility(
				squadBP,
				i, 
				"GlobalAbility_Ork_CultOfSpeed", 
				"global_ork_cult_of_speed_entity",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_Ork4.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				_pos = _self.LastCastedEntityPosition
				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-150))
				
				if(costSuccess) then
					
					ActivateSummonEntityAbility("ork_cult_of_speed_ability_caster", _self.CasterPlayer.Player, _pos)
				
				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				
				end
			end

			local AbilityStruct_Ork5 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
			--[[T0 All troops get 20% cost reduction for 30s]]
			--[[T1 Use ur choppa / use ur dakka]]
			--[[T2 Summon 3 squad of feral boys at target location for free tie up]]
			--[[T2 Cult of speed, increase speed of all vehicles by 30% also affects allies, decrease reload time by 30%]]
			--[[T3 Summon boss banner, every 1s reinforce an entity or leader to squad nearby, when banner is destroyed all orks turn on eachother. when destroyed play the campaign voice lines for it]] 
	
		--[[SISTERS GLOBALS]]
		elseif(RaceName == "sisters_race") then	
			
			local AbilityStruct_Sisters1 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Sisters2 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Sisters3 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Sisters4 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Sisters5 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
			--[[T0 summon a shrine that provides faith over time. troops near it also get morale resistance and a speed boost of 20%. shrine has HP and can be destroyed, use a small living saint shrine model for this]]
			--[[T1 Blessed Armour - Target squad gets damage and morale resistance of 50% and restore their morale, lasts 40s]]
			--[[T2 Target location and deploy 5 or 6 fire mines in the area]]
			--[[T2 All flame based troops get a damage buff globally (cellestian, inferno pistol, penitent, immolator)]]
			--[[T3
				200 Req, 80 Power --Is this necessary?
				Loyal Servant of the Imperium: Summon random loyalist troop, special version that is already fully upgraded to appropriate level, choose from pool of good units
				Pool:
					Grey Knights
					Purifier
					Purgation
					Ogryn
					Veteran of Typhon
					Veterans of Aurelia
			 ]]

		--[[SPACE MARINE GLOBALS]]
		elseif(RaceName == "space_marine_race") then

			--[[local AbilityStruct_SpaceMarine1 = CreateGlobalAbility(
				squadBP.."_basic_scan",
				i, 
				"GlobalAbility_SpaceMarines_BasicScan", 
				"global_space_marines_basic_scan_entity",
				"TARGETED",
				"GROUND",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_SpaceMarine1.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				_pos = _self.LastCastedEntityPosition
				local fxYOffset = 5 
				local fxSpawnPos = _pos
				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-30))
				
				if(costSuccess) then

					fxSpawnPos.y = _pos.y + fxYOffset
					World_FXEvent("data:Art/Events/Races/Space_Marines/Abilities/space_marine_global_basic_scan", fxSpawnPos)
					ActivateSummonEntityAbility("marines_detection_field_hq", _self.CasterPlayer.Player, _pos)
				
				else
					
					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				
				end

			end]]

			mod_MarinesForTheEmperor__modifier_01 = Modifier_Create(MAT_Squad, "max_damage_weapon_modifier", MUT_Multiplication, 1, 1.4, "")
			table.insert(g_GlobalAbilityMods, mod_MarinesForTheEmperor__modifier_01)
			mod_MarinesForTheEmperor__modifier_02 = Modifier_Create(MAT_Squad, "min_damage_weapon_modifier", MUT_Multiplication, 1, 1.4, "")
			table.insert(g_GlobalAbilityMods, mod_MarinesForTheEmperor__modifier_02)
			mod_MarinesForTheEmperor__modifier_03 = Modifier_Create(MAT_Squad, "accuracy_ranged_weapon_modifier", MUT_Multiplication, 1, 1.025, "")
			table.insert(g_GlobalAbilityMods, mod_MarinesForTheEmperor__modifier_03)
			mod_MarinesForTheEmperor__modifier_04 = Modifier_Create(MAT_Squad, "special_attack_physics_mass", MUT_Multiplication, 1, 1.2, "")
			table.insert(g_GlobalAbilityMods, mod_MarinesForTheEmperor__modifier_04)
			mod_MarinesForTheEmperor__modifier_05 = Modifier_Create(MAT_Squad, "morale_maximum_squad_modifier", MUT_Multiplication, 1, 1.2, "")
			table.insert(g_GlobalAbilityMods, mod_MarinesForTheEmperor__modifier_05)
			mod_MarinesForTheEmperor__modifier_06 = Modifier_Create(MAT_Squad, "morale_rate_squad_modifier", MUT_Multiplication, 1, 1.4, "")
			table.insert(g_GlobalAbilityMods, mod_MarinesForTheEmperor__modifier_06)
			modFX_MarinesForTheEmperor__modifier_01 = Modifier_Create(MAT_Squad, "ability_fighting_juice_event", MUT_Enable, 1, 1, "")	
			table.insert(g_GlobalAbilityMods, modFX_MarinesForTheEmperor__modifier_01)

			local AbilityStruct_SpaceMarine1 = CreateGlobalAbility(
				squadBP.."_for_the_emperor",
				i, 
				"GlobalAbility_SpaceMarines_ForTheEmperor", 
				"global_space_marines_for_the_emperor_entity",
				"TARGETED",
				"GROUND",
				table.getn(g_AllTrackedAbilities)
			)
	
			
			AbilityStruct_SpaceMarine1.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				_pos = _self.LastCastedEntityPosition

				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-50))
				if(costSuccess) then
					local AcceptedArmourTypes = {"tp_commander", "tp_infantry_heavy_med", "tp_infantry_heavy_high", "tp_infantry_med", "tp_infantry_high" }
					
					local own, _, _, _ = GetAllPlayerRelationships(_self.CasterPlayer)		
					--Later on should we allow this to be applied to all loyalist factions? just got to consider the FX spillover.	
					--allies = TableMerge({allies, own})		
					local SquadsWithAcceptedArmour = GetAllSquadsOfArmourTypeFromPlayerTable(own, AcceptedArmourTypes, true)
					local ClosestSquad = GetClosestSquadInSquadTableToPos(SquadsWithAcceptedArmour, _pos, 10)
					
					if(ClosestSquad ~= nil) then
						World_FXEvent("data:Art/Events/Races/Space_Marines/Abilities/space_marine_global_basic_scan", _pos)
						_self.ModFX = Modifier_ApplyToSquad(modFX_MarinesForTheEmperor__modifier_01, ClosestSquad.SquadID)
						
						_self.TargetSquad = ClosestSquad
						_self.Duration = 30
						_self.FX_RefireRate = 0.1
						_self.FX_LastFireTime = 0
						_self.FX_Table = {}
						_self.AppliedMods = {}
						table.insert(_self.AppliedMods, Modifier_ApplyToSquad(mod_MarinesForTheEmperor__modifier_01, _self.TargetSquad.SquadID))
						table.insert(_self.AppliedMods, Modifier_ApplyToSquad(mod_MarinesForTheEmperor__modifier_02, _self.TargetSquad.SquadID))
						table.insert(_self.AppliedMods, Modifier_ApplyToSquad(mod_MarinesForTheEmperor__modifier_03, _self.TargetSquad.SquadID))
						table.insert(_self.AppliedMods, Modifier_ApplyToSquad(mod_MarinesForTheEmperor__modifier_04, _self.TargetSquad.SquadID))
						table.insert(_self.AppliedMods, Modifier_ApplyToSquad(mod_MarinesForTheEmperor__modifier_05, _self.TargetSquad.SquadID))
						table.insert(_self.AppliedMods, Modifier_ApplyToSquad(mod_MarinesForTheEmperor__modifier_06, _self.TargetSquad.SquadID))

						
						_self.ActivatedTime = g_WorldTime
						_self:ActivateTimedAbility()
					
					else

						Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to no targets in area.")
					
					end

				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				
				end

			end

			AbilityStruct_SpaceMarine1.TimedAbilityEnd = function( _self )

				Log(eLOG_TYPE_INFO, eLOG_SIMPLE, _self.AbilityName.. " finished.")
				
				if(_self.ModFX ~= nil) then

					if(Modifier_Exists(_self.ModFX)) then

						pcall(Modifier_Remove, _self.ModFX)

					end

				end

				for i = 1, TableLength(_self.FX_Table) do

					World_FXEventDestroy(_self.FX_Table[i])

				end
				
				for i = 1, TableLength(_self.AppliedMods) do

					if(_self.AppliedMods[i] ~= nil) then

						if(Modifier_Exists(_self.AppliedMods[i])) then

							pcall(Modifier_Remove, _self.AppliedMods[i])

						end

					end

				end

			end
			
			local AbilityStruct_SpaceMarine2 = CreateGlobalAbility(
				squadBP.."_drop_pod",
				i, 
				"GlobalAbility_SpaceMarines_DropPod", 
				"global_space_marines_drop_pod_entity",
				"TARGETED",
				"GROUND",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_SpaceMarine2.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				_pos = _self.LastCastedEntityPosition
				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-75))

				if(costSuccess) then

					_self.DropPodID = GetUniqueSG("GlobalAbility_SM_DropPod")					
					Util_CreateSquadsAndDropPodIn_GlobalAbility( _self.CasterPlayer.Player, SGroup_GetName(_self.DropPodID), "space_marine_squad_drop_pod_emplacement", _pos, 1, 1 )
					
				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				
				end

			end		

			local AbilityStruct_SpaceMarine3 = CreateGlobalAbility(
				squadBP.."_basic_scan",
				i, 
				"GlobalAbility_SpaceMarines_GlobalScan", 
				"global_space_marines_global_scan_entity",
				"TARGETED",
				"GROUND",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_SpaceMarine3.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				_pos = _self.LastCastedEntityPosition
				local fxYOffset = 5 
				local fxSpawnPos = _pos
				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-100))
				
				if(costSuccess) then

					fxSpawnPos.y = _pos.y + fxYOffset
					World_FXEvent("data:Art/Events/Races/Space_Marines/Abilities/space_marine_global_basic_scan", fxSpawnPos)
					ActivateSummonEntityAbility("marines_global_vision_steal_ability_caster", _self.CasterPlayer.Player, _pos)
				
				else
					
					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				
				end

			end

			local AbilityStruct_SpaceMarine4 = CreateGlobalAbility(
				squadBP.."_blessings_of_omnissiah",
				i, 
				"GlobalAbility_SpaceMarines_BlesingsOfOmnissiah", 
				"global_space_marines_blessings_of_omnissiah_entity",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_SpaceMarine4.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				_pos = _self.LastCastedEntityPosition
				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-150))
				
				if(costSuccess) then
					
					ActivateSummonEntityAbility("marines_blessing_of_omnissiah_ability_caster", _self.CasterPlayer.Player, _pos)
				
				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				
				end

			end
			
			local AbilityStruct_SpaceMarine5 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			--T1 For the emperor, damage buff and kb resistance
			--T2 Single drop pod that does high KB to enemy and provides cover around it and decreases reinforce time, can be destroyed if focused. possibly make it able to produce tacs and maybe give it addons like tunnel
			--T2 Blessing of omnissiah to heal all vehicles
			--T3 EMP, in area stun all buildings and vehicles, prevent ranged shooting for 20s, prevent all tp, mechanical based infantry slowed down like nw, wg etc. AoE expanding 

		--[[SPACE MARINE VETERANS GLOBALS]]
		elseif(RaceName == "space_marine_veteran_race") then	

			local AbilityStruct_Veterans1 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Veterans2 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Veterans3 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Veterans4 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Veterans5 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
			--[[T2 Reveal all enemy line of sight for a time?]]

		--[[TAU GLOBALS]]
		elseif(RaceName == "tau_race") then
			
			local AbilityStruct_Tau1 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Tau2 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Tau3 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Tau4 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Tau5 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
			--[[Reveal all gens line of sight and possibly lp line of sight too. would be good to have it so the gen under construction also ]]

		--[[GUARD GLOBALS]]
		elseif(RaceName == "guard_race") then
			
			--Global 1   --WE NEED TO MAKE THIS MAKE A SOUND FOR ALL PLAYERS TO HEAR
			local AbilityStruct_Guard1 = CreateGlobalAbility(
				squadBP.."_tunnel_network",
				i, 
				"GlobalAbility_Guard_SummonBunker", 
				"global_guard_summon_bunker_entity",
				"TARGETED",
				"GROUND",
				table.getn(g_AllTrackedAbilities)
			)
			
			local AbilityStruct_Guard2 = CreateGlobalAbility(
				squadBP,
				i, 
				"GlobalAbility_Guard_DebuffFlare", 
				"guard_flare_debuff_ability_caster",
				"TARGETED",
				"GROUND",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Guard3 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Guard4 = CreateGlobalAbility(
				squadBP,
				i, 
				"GlobalAbility_Guard_ValkyrieReinforce", 
				"global_guard_valkyrie_reinforce_entity",
				"TARGETED",
				"GROUND",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Guard5 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_Guard1.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				_pos = _self.LastCastedEntityPosition				
				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-30, -100))

				if(costSuccess) then

					ActivateAutoConstructionAbility(_pos, _self.CasterPlayer, "guard_infantry_summon")
				
				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				
				end

			end

			AbilityStruct_Guard2.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				_pos = _self.LastCastedEntityPosition				
				_self.Duration = 4
				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-50))

				if(costSuccess) then

					ActivateSummonEntityAbility("guard_flare_debuff_ability_caster", _self.CasterPlayer.Player, _pos)
					_self.LoopingFX = World_FXEventLooping( "data:Art/Events/Races/guard/Abilities/guard_debuff_flare_combo", _pos )
					World_FXEvent("data:Art/Events/Races/Space_Marines/Abilities/space_marine_global_basic_scan", fxSpawnPos)
					
					_self.ActivatedTime = g_WorldTime
					_self:ActivateTimedAbility()
				
				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				
				end

			end
			
			--Not working?
			AbilityStruct_Guard2.TimedAbilityEnd = function(_self)	

				World_FXEventDestroy(_self.LoopingFX) 
				
			end

			AbilityStruct_Guard4.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )
	
				_pos = _self.LastCastedEntityPosition		
				local costSuccess = FireCost(_self.CasterPlayer, ResourceGroup:new(-150))

				if(costSuccess) then

					--[[ init ability globals ]]
					_self.TimeToDoReinforceLogic = g_WorldTime + 5.5 --4s delay
					_self.TimeToRemoveDropShip = g_WorldTime + 8 --10s delay
					_self.Duration = 18 --This is when ability finally ends, so the cleanup
					_self.HasReinforcedTroops = false
					_self.HasRemovedDropShip = false	

					--[[ create the drop ship ]]
					local squadID = ActivateSummonSquadAbility("npc_valkyrie", _self.CasterPlayer.Player, _pos, 1)
					local sgroupID = GetUniqueSG("npc_valkyrie")			
					_self.DropPodSquadGroupID = sgroupID
					local sgroupName = SGroup_GetName(sgroupID)
					SGroup_Add(sgroupID, squadID)
					Anim_PlaySGroupAnim(sgroupID, "sp_land")
					SGroup_SetHealthInvulnerable(sgroupName, true)
					
					_self.ActivatedTime = g_WorldTime
					_self:ActivateTimedAbility()
				
				else

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._self.AbilityName.."' due to lack of resources.")
				
				end

			end
			
			AbilityStruct_Guard4.TimedAbilityUpdate = function(_self)
			
				if(_self.HasReinforcedTroops == false) then
					if(g_WorldTime >= _self.TimeToDoReinforceLogic) then

						_self.DeployTroops(_self)
						_self.HasReinforcedTroops = true
						
					end
				end	

				if(_self.HasRemovedDropShip == false) then
					if(g_WorldTime >= _self.TimeToRemoveDropShip) then

						Anim_PlaySGroupAnim(_self.DropPodSquadGroupID, "sp_take_off")
						_self.HasRemovedDropShip = true

					end
				end	
			end
			
			AbilityStruct_Guard4.TimedAbilityEnd = function(_self)	

				local sgName = SGroup_GetName(_self.DropPodSquadGroupID) 
				SGroup_DeSpawn(sgName)
				SGroup_DestroyAllSquads(sgName)

			end
			
			AbilityStruct_Guard4.DeployTroops = function( _self )

				_pos = _self.LastCastedEntityPosition

				local validRespawnSquads = { "guard_squad_command_squad", "guard_squad_guardsmen", "guard_squad_guardsmen_rider","guard_squad_kasrkin", "guard_squad_spotter", "guard_squad_ogryns" }
				local validWeaponUpgrades = { "guard_grenade_launcher_guardsmen", "guard_plasma_gun_guardsmen", "guard_grenade_launcher_kasrkin", "guard_plasma_gun_kasrkin" }
				local validHealSquads = { "guard_squad_guardsmen", "guard_squad_assassin", "guard_heavy_weapons_team_squad", "guard_squad_command_squad", "guard_squad_commissar", "guard_squad_enginseer", "guard_squad_priest", "guard_squad_psyker" }
				local validAddLeaderSingularSquads = { "guard_squad_guardsmen", "guard_squad_guardsmen_rider","guard_squad_kasrkin", "guard_squad_ogryns" }
				local validAddLeaderMultipleSquads = { "guard_squad_command_squad" }

				--Later on we will need to make sure this squad inherits XP etc.
				local RespawnSquadAtFull = function( sgroupid, itemindex, squadID )

					local squadBP = Squad_GetBlueprintName(squadID)
					local sgroupIDRespawn = GetUniqueSG("respawn_troopers")
					local sgroupRespawnName = SGroup_GetName(sgroupIDRespawn)
					local squadPos = Squad_GetPosition(squadID)
					
					local isValidRespawn, _ = TableContains(validRespawnSquads, squadBP)
					local isValidHeal, _ = TableContains(validHealSquads, squadBP)
					local isValidAddLeader, _ = TableContains(validAddLeaderSingularSquads, squadBP)
					local isValidAddLeaderMultiple, _ = TableContains(validAddLeaderMultipleSquads, squadBP)
					local currentLeaderCount = Squad_CountLeaders(squadID)

					if(isValidRespawn) then
						local hasAttached = false
						local attachedBP = nil
						local allAttachedWeapons = {}						

						--Get current weapons for the current squad
						for i = 1, TableLength(validWeaponUpgrades) do
							if(Squad_CanUpgradeWeapon( squadID, validWeaponUpgrades[i] )) then 
								local count = Squad_WeaponCount(squadID, validWeaponUpgrades[i])
								allAttachedWeapons[validWeaponUpgrades[i]] = count
							end
						end

						if(Squad_IsAttached( squadID )) then
							hasAttached = true
							attachedBP = Squad_GetAttachedBlueprintName( squadID )
						end						
						
						--Despawn and respawn squad at full size
						Squad_DeSpawn(squadID)
						local loadout = 1000
						
						--Special cases that have varying squad sizes. any units that have a change in squad size need special adjustments here in code as game not smart enough to work out mods
						if(squadBP == "guard_squad_guardsmen") then
							if(Player_GetResearchState(_self.CasterPlayer.Player, "guard_gu_members_t2") == RS_Complete) then
								if(Player_GetResearchState(_self.CasterPlayer.Player, "guard_gu_members_t3") == RS_Complete) then
									if(Player_GetResearchState(_self.CasterPlayer.Player, "guard_gu_members_t4") == RS_Complete) then
										loadout = 13
									else
										loadout = 11
									end
								else
									loadout = 9
								end
							else
								loadout = 7
							end
						elseif(squadBP == "guard_squad_guardsmen_rider") then
							if(Player_GetResearchState(_self.CasterPlayer.Player, "guard_upgrade_rider_melee") == RS_Complete) then
								loadout = 9
							else
								loadout = 7
							end
						end

						squadID = ActivateSummonSquadAbility(squadBP, _self.CasterPlayer.Player, squadPos, loadout)
						SGroup_Add(sgroupRespawnName, squadID)

						--Respawn the attached leader and attach him
						if(hasAttached == true) then
							local attachSquadID = ActivateSummonSquadAbility(attachedBP, _self.CasterPlayer.Player, squadPos, 1)
							local sgroupIDAttach = GetUniqueSG("attach_troopers")
							local sgroupIDAttachName = SGroup_GetName(sgroupIDAttach)
							SGroup_Add(sgroupIDAttach, attachSquadID)
							Cmd_AttachSquads( sgroupIDAttachName, sgroupRespawnName ) --Not working!!?? need to adjust later
						end

						--Try add weapons to the respawned squad, same as he had before
						for i = 1, TableLength(validWeaponUpgrades) do
							if(allAttachedWeapons[validWeaponUpgrades[i]] ~= nil) then 
								local count = allAttachedWeapons[validWeaponUpgrades[i]]
								if(count > 0) then
									Squad_ForceUpgradeWeapons(squadID, validWeaponUpgrades[i], count)
								end
							end
						end

					else
						
						SGroup_Add(sgroupRespawnName, squadID)
						Squad_SetMorale(squadID, 1)
						SGroup_Remove(sgroupid, squadID)

					end
					

					if(isValidHeal) then

						SGroup_SetAvgHealth(sgroupRespawnName, 1)

					end

					if(isValidAddLeader) then

						Squad_AddLeader( squadID )

					end

					if(isValidAddLeaderMultiple) then
						local extraLeaders = 0
						local baseLeaders = 3
						
						if(Player_GetResearchState(_self.CasterPlayer.Player, "guard_research_command_squad_size") == RS_Complete) then
							extraLeaders = 1
						end

						for i = 1 + currentLeaderCount, baseLeaders + extraLeaders do
							
							local newLeaderIndex = i
							if(newLeaderIndex > 3) then 
								newLeaderIndex = World_GetRand(1,3)
							end
							Squad_AddLeaderAtIndex( squadID, newLeaderIndex )
						end

					end
				end

				local sgroupID = GetUniqueSG("reinforce_troopers")
				local sgroupName = SGroup_GetName(sgroupID)
				
				_pos = World_Pos(_pos.x, _pos.y, _pos.z)
				Player_GetAllSquadsNearPos(_self.CasterPlayer.Player, sgroupName, _pos, 15)
				SGroup_ForEach( sgroupID, RespawnSquadAtFull )
				SGroup_DestroyAllSquads(sgroupName)
				SGroup_Destroy(sgroupName)
				
				--Rule_AddOneShot(Rule_IG_EmergencyDrop_TakeOff, 15)

			end

			--[[T1 flare that lowers sight range of enemies]]
			--[[T2 off-map artillery, select location and then 3 mouse locations will be selected to target the strike]]
			--^^ change this to the chinese artillery global
			--[[T2 deploy a valkyrie and reinforce all squads to full]]
			--[[T3 PDF Reinforcements, valkyrie drop 1 goty leman russ with less hp than a regular leman, 2 PDF guardsmen squads fully reinforced with random weaponry, and colonel brom]]

		--[[ORDO MALLEUS GLOBALS]]
		elseif(RaceName == "inquisition_daemonhunt_race") then
			
			local AbilityStruct_Inquisition1 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
			
			local AbilityStruct_Inquisition2 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Inquisition3 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Inquisition4 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
			
			local AbilityStruct_Inquisition5 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
			--T0 Restore abilities on target squad
			--T1 Psychic assailment, increase range, sight, and range damage of squad
			--T2 Spawn a relic on the map, can be captured by a squad and brought back to one of your structures for a benefit
			--T2 Buff all flame weaponry
			--Choose an enemy squad or structure and it can't produce a certain thing for awhile
			--T3 Exterminatus?
		elseif(RaceName == "tyranids_race") then
			local AbilityStruct_Tyranids1 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
			
			local AbilityStruct_Tyranids2 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Tyranids3 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			local AbilityStruct_Tyranids4 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
			
			local AbilityStruct_Tyranids5 = CreateGlobalAbility(
				squadBP,
				i, 
				"", 
				"",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)
					

			--Restricts the free abilities
			PreRestrictHiveTyrantFreeWeaponSwapAbilities(g_AllPlayers[i].Player)

			--Block the abilities for starting loadout of hive tyrant
			RestrictAndUnrestrictHiveTyrantWeaponSwapAbilities(g_AllPlayers[i].Player, "tyranids_hive_tyrant_weapon_swap_talons_bottom", false)
			RestrictAndUnrestrictHiveTyrantWeaponSwapAbilities(g_AllPlayers[i].Player, "tyranids_hive_tyrant_weapon_swap_talons_top", true)


			if(CurrentHiveTyrantTopWeapon == nil) then
				
				CurrentHiveTyrantTopWeapon = {}
				CurrentHiveTyrantBottomWeapon = {}

			end

			CurrentHiveTyrantTopWeapon[i] = "tyranids_hive_tyrant_weapon_swap_talons_top"
			CurrentHiveTyrantBottomWeapon[i] = "tyranids_hive_tyrant_weapon_swap_talons_bottom"

			local AbilityStruct_TyranidsForceUpgradeHiveTyrant_TalonsBottom = CreateGlobalAbility(
				squadBP,
				i, 
				"Tyranids_ForceUpgradeHiveTyrantTalonsBottom", 
				"tyranids_hive_tyrant_force_upgrade_talons_bottom_entity",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_TyranidsForceUpgradeHiveTyrant_TalonsBottom.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				ActivateForceUpgradeHiveTyrantAbility(_self.LastCastedEntityPosition, _self.CasterPlayer, "tyranids_scything_talons_hive_tyrant_bottom", "tyranids_hive_tyrant_weapon_swap_talons_bottom", false)
				
			end

			local AbilityStruct_TyranidsForceUpgradeHiveTyrant_BarbedStrangler = CreateGlobalAbility(
				squadBP,
				i, 
				"Tyranids_ForceUpgradeHiveTyrantBarbedStrangler", 
				"tyranids_hive_tyrant_force_upgrade_barbed_strangler_entity",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_TyranidsForceUpgradeHiveTyrant_BarbedStrangler.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				ActivateForceUpgradeHiveTyrantAbility(_self.LastCastedEntityPosition, _self.CasterPlayer, "tyranids_barbed_strangler_hive_tyrant", "tyranids_hive_tyrant_weapon_swap_barbed_strangler", false)

			end
				
			local AbilityStruct_TyranidsForceUpgradeHiveTyrant_VenomCannon = CreateGlobalAbility(
				squadBP,
				i, 
				"Tyranids_ForceUpgradeHiveTyrantVenomCannon", 
				"tyranids_hive_tyrant_force_upgrade_venom_cannon_entity",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_TyranidsForceUpgradeHiveTyrant_VenomCannon.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )
				
				ActivateForceUpgradeHiveTyrantAbility(_self.LastCastedEntityPosition, _self.CasterPlayer, "tyranids_venom_cannon_hive_tyrant", "tyranids_hive_tyrant_weapon_swap_venom_cannon", false)

			end
	
			local AbilityStruct_TyranidsForceUpgradeHiveTyrant_TalonsTop = CreateGlobalAbility(
				squadBP,
				i, 
				"Tyranids_ForceUpgradeHiveTyrantTalonsTop", 
				"tyranids_hive_tyrant_force_upgrade_talons_top_entity",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_TyranidsForceUpgradeHiveTyrant_TalonsTop.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				ActivateForceUpgradeHiveTyrantAbility(_self.LastCastedEntityPosition, _self.CasterPlayer, "tyranids_scything_talons_hive_tyrant_top", "tyranids_hive_tyrant_weapon_swap_talons_top", true)
				
			end

			local AbilityStruct_TyranidsForceUpgradeHiveTyrant_Devourer = CreateGlobalAbility(
				squadBP,
				i, 
				"Tyranids_ForceUpgradeHiveTyrantDevourer", 
				"tyranids_hive_tyrant_force_upgrade_devourer_entity",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_TyranidsForceUpgradeHiveTyrant_Devourer.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				ActivateForceUpgradeHiveTyrantAbility(_self.LastCastedEntityPosition, _self.CasterPlayer, "tyranids_devourer_hive_tyrant", "tyranids_hive_tyrant_weapon_swap_devourer", true)
				
			end
						
			local AbilityStruct_TyranidsForceUpgradeHiveTyrant_BoneSwordWhip = CreateGlobalAbility(
				squadBP,
				i, 
				"Tyranids_ForceUpgradeHiveTyrantBoneSwordWhip", 
				"tyranids_hive_tyrant_force_upgrade_bone_sword_whip_entity",
				"TIMED",
				"NONE",
				table.getn(g_AllTrackedAbilities)
			)

			AbilityStruct_TyranidsForceUpgradeHiveTyrant_BoneSwordWhip.DoAbility = function( _self, _pos, _targetSquad, _targetEntity )

				ActivateForceUpgradeHiveTyrantAbility(_self.LastCastedEntityPosition, _self.CasterPlayer, "tyranids_bone_sword_whip_hive_tyrant", "tyranids_hive_tyrant_weapon_swap_bone_sword_whip", true)
				
			end
			
		else

			Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Race '"..RaceName.."' is undefined in if statement! Assuming it has no global abilities.")
		
		end

	end

	RemoveStacktrace()

end

function Util_CreateSquadsAndDropPodIn_GlobalAbility( playerId, squadgroupName, squadBlueprint, pos, numsquads, loadout )

	AddStacktrace("Util_CreateSquadsAndDropPodIn_GlobalAbility")

	local groupID = _ScarUtil_Private.CreateSquads(
		playerId,
		squadgroupName,
		squadBlueprint,
		pos,
		numsquads,
		loadout,
		false -- do not spawn
	)
	
	Util_DropPod_GlobalAbility( squadgroupName, pos )
	
	RemoveStacktrace()

	return groupID

end

function Util_DropPod_GlobalAbility( sgroupname, pos )

	AddStacktrace("Util_DropPod_GlobalAbility")

	-- depspawn
	SGroup_DeSpawn( sgroupname )
	-- drop pod
	Squad_DeepStrikeToPos( sgroupname, "space_marine_global_ability_drop_pod_building", pos )
	
	RemoveStacktrace()

end

--Do this later, requires fire cost to be built into ability as well as being a function
--[[function CheckGlobalAbilityRequirements()

	for player = 1, g_PlayerCount do
		if(g_AllPlayers[player].PlayerIndex = Tut_GetLocalPlayerIndex()) then

			for i = 1, table.getn(g_AllTrackedAbilities) do

				if(g_AllPlayers[player].CurrentResources.RT_Requisition < g_AllTrackedAbilities.FireCost)

			end

		end
	end

end]]

function PreRestrictHiveTyrantFreeWeaponSwapAbilities(_Player)

	local hiveTyrantWeaponsAbilities = 
	{		
		"tyranids_hive_tyrant_weapon_swap_talons_top_free",
		"tyranids_hive_tyrant_weapon_swap_devourer_free",
		"tyranids_hive_tyrant_weapon_swap_bone_sword_whip_free",
		"tyranids_hive_tyrant_weapon_swap_talons_bottom_free",
		"tyranids_hive_tyrant_weapon_swap_barbed_strangler_free",
		"tyranids_hive_tyrant_weapon_swap_venom_cannon_free"	
	}
	
	for i = 1, table.getn(hiveTyrantWeaponsAbilities) do

		Player_RestrictAbility(_Player, hiveTyrantWeaponsAbilities[i])

	end

end

function RestrictAndUnrestrictHiveTyrantWeaponSwapAbilities(_Player, _AbilityName, _IsTopWeapon)

	local hiveTyrantWeaponsAbilitiesToUnrestrict = {}

	if(_IsTopWeapon) then

		hiveTyrantWeaponsAbilitiesToUnrestrict = 
		{		
			"tyranids_hive_tyrant_weapon_swap_talons_top",
			"tyranids_hive_tyrant_weapon_swap_devourer",
			"tyranids_hive_tyrant_weapon_swap_bone_sword_whip"
		}

	else

		hiveTyrantWeaponsAbilitiesToUnrestrict = 
		{		
			"tyranids_hive_tyrant_weapon_swap_talons_bottom",
			"tyranids_hive_tyrant_weapon_swap_barbed_strangler",
			"tyranids_hive_tyrant_weapon_swap_venom_cannon"		
		}

	end	
	
	for i = 1, table.getn(hiveTyrantWeaponsAbilitiesToUnrestrict) do
		
		Player_UnRestrictAbility( _Player, hiveTyrantWeaponsAbilitiesToUnrestrict[i] )

	end

	Player_RestrictAbility(_Player, _AbilityName)

end

function ActivateForceUpgradeHiveTyrantAbility(_Pos, _PlayerStruct, _WeaponName, _AbilityName, _IsTopWeapon)

	local allHiveTyrants = GetAllSquadsOfBlueprint(_PlayerStruct.PlayerIndex+1, {"tyranids_squad_hive_tyrant"} )
	local closestHiveTyrant = GetClosestSquadInSquadTableToPos(allHiveTyrants, _Pos, 10)

	if(closestHiveTyrant ~= nil) then
		
		Squad_ForceUpgradeWeapons(closestHiveTyrant.SquadID, _WeaponName, 0)
		RestrictAndUnrestrictHiveTyrantWeaponSwapAbilities(_PlayerStruct.Player, _AbilityName, _IsTopWeapon)
					
	else

		Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Failed to cast global ability '".._AbilityName.."' as no Hive Tyrant found.")
	
	end

end

function ActivateMultiSummonEntityAbility(_EBP, _Player, _Pos, _RandomOffsetPerEntity, _NumberOfEntities) 

	AddStacktrace("ActivateMultiSummonEntityAbility")

	local AllCreatedEntities = {}
	
	_Pos = World_Pos(_Pos.x, _Pos.y, _Pos.z)

	for i = 1, _NumberOfEntities do

		local tmpPos = _Pos
		tmpPos.x = _Pos.x + World_GetRand(-_RandomOffsetPerEntity.x, _RandomOffsetPerEntity.x)
		tmpPos.y = _Pos.y + World_GetRand(-_RandomOffsetPerEntity.y, _RandomOffsetPerEntity.y)
		tmpPos.z = _Pos.z + World_GetRand(-_RandomOffsetPerEntity.z, _RandomOffsetPerEntity.z)
		table.insert(AllCreatedEntities, ActivateSummonEntityAbility(_EBP, _Player, tmpPos, _Loadout))
		
	end

	RemoveStacktrace()

	return AllCreatedEntities

end

function ActivateSummonEntityAbility(_EBP, _Player, _Pos)
	
	AddStacktrace("ActivateSummonEntityAbility")

	_Pos = World_Pos(_Pos.x, _Pos.y, _Pos.z)
	local entity = Entity_Create(_EBP, _Player, _Pos)
	Entity_Spawn(entity)

	RemoveStacktrace()

	return entity
end

function ActivateMultiSummonSquadAbility(_SBP, _Player, _Pos, _RandomOffsetPerSquad, _NumberOfSquads, _LoadoutMin, _LoadoutMax) 

	AddStacktrace("ActivateMultiSummonSquadAbility")

	local AllCreatedSquads = {}
	_Pos = World_Pos(_Pos.x, _Pos.y, _Pos.z)

	for i = 1, _NumberOfSquads do

		local tmpPos = _Pos
		local loadout = World_GetRand(_LoadoutMin, _LoadoutMax)
		tmpPos.x = _Pos.x + World_GetRand(-_RandomOffsetPerSquad.x, _RandomOffsetPerSquad.x)
		tmpPos.y = _Pos.y + World_GetRand(-_RandomOffsetPerSquad.y, _RandomOffsetPerSquad.y)
		tmpPos.z = _Pos.z + World_GetRand(-_RandomOffsetPerSquad.z, _RandomOffsetPerSquad.z)
		table.insert(AllCreatedSquads, ActivateSummonSquadAbility(_SBP, _Player, tmpPos, loadout))

	end

	RemoveStacktrace()

	return AllCreatedSquads

end

function ActivateSummonSquadAbility(_SBP, _Player, _Pos, _Loadout)
	
	AddStacktrace("ActivateSummonSquadAbility")

	_Pos = World_Pos(_Pos.x, _Pos.y, _Pos.z)
	local squad = Squad_Create(_SBP, _Player, _Pos, _Loadout)
	Squad_Spawn(squad, _Pos)

	RemoveStacktrace()

	return squad
end

--What is this variable? is it needed anymore? why is it defined so low in the code!?
timeSinceAbilityPress = 0
function Update_GlobalAbilities()
	
	AddStacktrace("Update_GlobalAbilities")

	--[[	--Maybe we could do this for singleplayer?
	emptySGroupID = SGroup_CreateIfNotFound("emptySGroup")
	if(SGroup_Exists("GlobalAbilityCasterTest") == false) then
		Util_CreateSquadsAtPosition(g_AllPlayers[1].Player, SGroup_GetName(SGroup_Create("GlobalAbilityCasterTest")), "world_squad_global_ability_caster_necron_race", World_Pos(0,0,0), 1)
		Util_CreateSquadsAtPosition(g_AllPlayers[2].Player, SGroup_GetName(SGroup_Create("GlobalAbilityCasterTest2")), "world_squad_global_ability_caster_necron_race", World_Pos(0,0,0), 1)
	end
	if(SGroup_IsSelected("GlobalAbilityCasterTest") or SGroup_IsSelected("GlobalAbilityCasterTest2")) then
		
		Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "UNSELECTING!!")
		local timed = false

		if(timed) then
			W40k_SelectSGroup(emptySGroupID)
			Cmd_CastAbilitySelf("GlobalAbilityCasterTest", "global_necron_production_overload")
		elseif(timeSinceAbilityPress > 3) then

			timeSinceAbilityPress = 0
			W40k_SelectSGroup(emptySGroupID)
			Cmd_CastAbilityPos("GlobalAbilityCasterTest", "global_necron_scarab_swarm", Misc_GetMouseOnTerrain())

		else
			timeSinceAbilityPress = timeSinceAbilityPress + 1
			Log(eLOG_TYPE_INFO, eLOG_SIMPLE, timeSinceAbilityPress)
		end
	end]]

	for i = 1, table.getn(g_AllTrackedAbilities) do

		g_AllTrackedAbilities[i]:Update()

	end

	Update_AllAbilityBuilders()

	RemoveStacktrace()
	
end


function CreateGlobalAbility(_LinkedSquadBP, _Player, _AbilityName, _ActivationEntityBP, _ActivationType, _TargetFilter)

	AddStacktrace("CreateGlobalAbility")
	
	local AbilityStruct = GlobalAbility:new(_LinkedSquadBP, _Player, _AbilityName, _ActivationEntityBP, _ActivationType, _TargetFilter, table.getn(g_AllTrackedAbilities))

	table.insert(g_AllTrackedAbilities, AbilityStruct)

	RemoveStacktrace()

	return AbilityStruct

end

function UpdateAbilityIconGraphics(_BtnID, _TextureTable, _TipTable, _Instructions)

	AddStacktrace("UpdateAbilityIconGraphics")

	if(_BtnID == nil) then

		Log(eLOG_LOG_TYPE_ERROR, eLOG_FULL, "Button is nil! Cannot update graphics.")

	elseif(Button_Exists(_BtnID) == nil) then

		Log(eLOG_LOG_TYPE_ERROR, eLOG_FULL, "Button does not exist! Cannot update graphics.")

	else

		Button_SetTextures(_BtnID, _TextureTable[1], _TextureTable[2], _TextureTable[3])
		Button_SetTooltip(_BtnID, _TipTable[1], _TipTable[2])
		Button_SetModalInstruction(_BtnID, _Instructions)

	end

	RemoveStacktrace()

	return buttonID

end

--Other costs can be added when needed, but likely via a different function as this will just interact direct with resource gen system
function FireCost(_Player, _ResourceGroup) 

	AddStacktrace("FireCost")

	local Success = _Player:HasEnoughResources(_ResourceGroup)
	
	if(Success) then

		_Player:AddFireCost(_ResourceGroup)

	end
	
	RemoveStacktrace()

	return Success

end

--What are these variable assignments doing here? should be in settings...!
devGlobalBuildertest = nil
devGloblabuildertestStruct = nil
UniqueBuilderSGroup = nil
function Dev_SetupAutoConstructor(_PlayerStruct)

	AddStacktrace("Dev_SetupAutoConstructor")

	_PlayerStruct = g_AllPlayers[1]
	UniqueBuilderSGroup = GetUniqueSG("tmpBuilderGroup")
	local UniqueBuilderSGroupName =  SGroup_GetName(UniqueBuilderSGroup)
	UniqueBuilderSGroup = Util_CreateSquadsAtPosition(_PlayerStruct.Player, UniqueBuilderSGroupName, "world_squad_global_builder", World_Pos(0,0,0), 1)
	devGloblabuildertestStruct = GlobalAbilityBuilder:new( _PlayerStruct.Player, UniqueBuilderSGroup, UniqueBuilderSGroupName, "" )

	RemoveStacktrace()

end

function Dev_MoveSquadToPosition(player, pos)

	AddStacktrace("Dev_MoveSquadToPosition")

	Command_SquadPos( 
		player.Player,
		UniqueBuilderSGroup,
		SCMD_Move,
		pos
	)	

	RemoveStacktrace()

end

function ActivateAutoConstructionAbility(_pos, _PlayerStruct, _structureEbps)

	AddStacktrace("ActivateAutoConstructionAbility")

	local UniqueBuildingEGroup = GetUniqueEG("tmpBuildingEGroup")
	local UniqueBuilderSGroup = GetUniqueSG("tmpBuilderGroup")
	local UniqueBuildingEGroupName = EGroup_GetName(UniqueBuildingEGroup)
	local UniqueBuilderSGroupName =  SGroup_GetName(UniqueBuilderSGroup)

	_pos = World_Pos(_pos.x,_pos.y,_pos.z)

	Entity_CreateBuildingPosition(_PlayerStruct.Player, UniqueBuildingEGroupName, _structureEbps, _pos, 0)

	--If group size is 0 we have not created the above entity. Likely due to it being placed in a bad position. Must show error and stop function
	if(EGroup_Count(UniqueBuildingEGroup) == 0) then

		UIWarning_Show( "FAILED TO CAST SUMMON ABILITY.\nCannot place structure at that position." )

	else

		Util_CreateSquadsAtPosition(_PlayerStruct.Player, UniqueBuilderSGroupName, "world_squad_global_builder", _pos, 1)

		table.insert(g_AllTrackedAbilityBuilders, GlobalAbilityBuilder:new( _PlayerStruct.Player, UniqueBuilderSGroup, UniqueBuilderSGroupName, UniqueBuildingEGroupName ))
		g_AllTrackedAbilityBuildersCount = g_AllTrackedAbilityBuildersCount + 1

	end

	RemoveStacktrace()

end

function Update_AllAbilityBuilders()

	AddStacktrace("Update_AllAbilityBuilders")

	for i = 1, g_AllTrackedAbilityBuildersCount do

		g_AllTrackedAbilityBuilders[i]:Update()

	end

	RemoveStacktrace()

end


function Util_GlobalAbilityButton_Create(_widgetName, _textureTable, _tipTable, _instructions, _visible, _enabled, _modal)

	AddStacktrace("Util_GlobalAbilityButton_Create")

	local buttonID = Button_Add(_widgetName, _visible, _enabled, _modal)

	if(buttonID == nil) then

		Log(eLOG_LOG_TYPE_ERROR, eLOG_FULL, "Button is nil after creation! pcall has been tripped, likely invalid arguments.")

	elseif(Button_Exists(buttonID) == nil) then

		Log(eLOG_LOG_TYPE_ERROR, eLOG_FULL, "Button does not exist after creation! Widget is likely in use.")

	else

		Button_SetVisible(buttonID, _visible)
		Button_SetTextures(buttonID, _textureTable[1], _textureTable[2], _textureTable[3])
		Button_SetTooltip(buttonID, _tipTable[1], _tipTable[2])
		Button_SetModalInstruction(buttonID, _instructions)

	end

	RemoveStacktrace()

	return buttonID

end