import("TFE_Core/Imports/TFECore_Imports.scar")

eBASIC_FUNCTION = 0
eREQUIRED_FUNCTION = 1

function Core_Game_Load()
	
	PWrap(Core_CheckForSecondaryScars)
	Rule_AddInterval(Core_MainLoop, g_WorldTimeFidelity)
	
end

function InvokeFunctionsFromFunctionTree(FuncTree)

	for _, branch in FuncTree do
		local func = branch.Function()
		--[[if pcall(func) == false and branch.Necessity == eREQUIRED_FUNCTION then

			LogError("Cannot run CRITICAL function!") 
		
		end]]

	end

end

function Core_Init_Load()

	AddStacktrace2("Core_Init_Load")

	local SetupFunctionTree = 
	{
		{ Function = Core_GetAllPlayers, Necessity = eREQUIRED_FUNCTION },
		{ Function = Setup_AlphaLegion, Necessity = eBASIC_FUNCTION },
		{ Function = Setup_PassiveResourceGeneration, Necessity = eREQUIRED_FUNCTION },
		{ Function = Setup_EntityManager, Necessity = eREQUIRED_FUNCTION },
		{ Function = Setup_SquadManager, Necessity = eREQUIRED_FUNCTION },
		{ Function = Setup_GlobalsStorage, Necessity = eREQUIRED_FUNCTION },
		{ Function = Setup_StrategicPoints, Necessity = eREQUIRED_FUNCTION },
		{ Function = Setup_MatureSystem, Necessity = eREQUIRED_FUNCTION },
		{ Function = Setup_UpkeepSystem, Necessity = eREQUIRED_FUNCTION },
		{ Function = Setup_NewCoverSystem, Necessity = eREQUIRED_FUNCTION },
		{ Function = Setup_WeatherSystems, Necessity = eREQUIRED_FUNCTION },
		{ Function = Setup_GlobalAbilities, Necessity = eREQUIRED_FUNCTION },
		{ Function = Setup_Achievements, Necessity = eREQUIRED_FUNCTION },
		{ Function = Setup_XPManager, Necessity = eREQUIRED_FUNCTION },
	}

	InvokeFunctionsFromFunctionTree( SetupFunctionTree )

	RemoveStacktrace2()

	return true	

end

function Core_CheckForSecondaryScars()
	
	if g_TrueRandomRace_Enabled == true then

		PWrap(TrueRandomRace_Setup)
	
	end

end

function Core_GetAllPlayers()
		
	for i = 1, g_PlayerCount do

		local Player = PWrap(World_GetPlayerAt, i-1)
		local PlayerIndex = PWrapUnsafe(World_GetPlayerIndex, Player)
		local RaceName = PWrapUnsafe(Player_GetRaceName, Player ) 
		local RaceIndex = PWrapUnsafe(Player_GetRace,  Player ) 
		local DisplayName = PWrapUnsafe(Player_GetDisplayName, Player)

		PWrap(Setup_PassiveResourceGeneration_Settings, RaceName)
		table.insert(g_AllPlayers, PlayerDetails:new( Player, PlayerIndex, DisplayName, RaceDetails:new (RaceName, RaceIndex, g_FactionSpecificResourceGeneration[RaceName] )))

		--Move this later
		if (UnitCosting[RaceName] == nil) then

			PWrap(import, 'upkeep/races/'..RaceName..'.scar')

		end
		
	end

	for i = 1, g_PlayerCount do
		
		--They need to be in reverse order so P1 is on top...
		PWrapUnsafe(WinWarning_Add, "UI_RatioIncomeVsUpkeep_Mixed"..g_AllPlayers[g_PlayerCount-i+1].PlayerIndex, g_AllPlayers[g_PlayerCount-i+1].Player, "", "Mature and Upkeep Counter", "This counter shows the specified players mature and upkeep." )
		PWrapUnsafe(WinWarning_Add, "UI_Accumulated_Red"..g_AllPlayers[g_PlayerCount-i+1].PlayerIndex, g_AllPlayers[g_PlayerCount-i+1].Player, "", "Red Counter", "This counter shows the ammount of gathered red for the player." )

	end

	if g_AI_AdvancedDifficultyScaling == true then

		PWrap(EnableAIAdvancedDifficulty)

	end

end


function Core_MainLoop()
	
	AddStacktrace2("Core_MainLoop")

	local MainLoopFunctionTree = 
	{
		{ Function = Set_UpdatedGameTime, Necessity = eREQUIRED_FUNCTION },
		{ Function = Set_AllSquads_Immediate, Necessity = eREQUIRED_FUNCTION },
		{ Function = Set_AllEntities_Immediate, Necessity = eREQUIRED_FUNCTION },
		{ Function = Set_AllSquadCoverModifiers, Necessity = eREQUIRED_FUNCTION },
		{ Function = Set_PlayerUpkeep, Necessity = eREQUIRED_FUNCTION },
		{ Function = Set_ResourceMature, Necessity = eREQUIRED_FUNCTION },
		{ Function = Implement_UpkeepAndMature, Necessity = eREQUIRED_FUNCTION },
		{ Function = Set_Weather, Necessity = eBASIC_FUNCTION },
		{ Function = Update_GlobalAbilities, Necessity = eBASIC_FUNCTION },
		{ Function = Update_Achievements, Necessity = eBASIC_FUNCTION },
		{ Function = Update_XPManager, Necessity = eBASIC_FUNCTION },
	}

	InvokeFunctionsFromFunctionTree(MainLoopFunctionTree)

	RemoveStacktrace2()
	
end

--Run this to cause the mod logic to stop
--Should only be used for critical errors
function ErrorPause()

	g_ModRunning = false
	Rule_RemoveAll()

end

function Implement_UpkeepAndMature()
	
	for i = 1, g_PlayerCount do
		
		local Index = g_PlayerCount - i +1
		--They need to be in reverse order so P1 is on top...
		if(PWrapUnsafe(Player_IsAlive, g_AllPlayers[Index].Player)) then

			if(PWrap(WinWarning_Exists,"UI_RatioIncomeVsUpkeep_Mixed"..g_AllPlayers[Index].PlayerIndex)) then
				
				local DisplayReqIncome = g_AllPlayers[Index].CurrentAddResources.RT_Requisition				
				local DisplayPowerIncome = g_AllPlayers[Index].CurrentAddResources.RT_Power 
				DisplayReqIncome = round(math.floor(DisplayReqIncome),2)
				DisplayPowerIncome = round(math.floor(DisplayPowerIncome),2)

				PWrap(WinWarning_SetText, "UI_RatioIncomeVsUpkeep_Mixed"..g_AllPlayers[Index].PlayerIndex, Loc_FormatText3(20050000, g_AllPlayers[Index].DisplayName,  DisplayReqIncome , DisplayPowerIncome ))
			
			else

				PWrap(WinWarning_Add, "UI_RatioIncomeVsUpkeep_Mixed"..g_AllPlayers[Index].PlayerIndex, g_AllPlayers[i].Player, "", "", "" )

			end

			if(PWrap(WinWarning_Exists, "UI_Accumulated_Red"..g_AllPlayers[Index].PlayerIndex)) then
				
				local DisplayTotalRed = g_AllPlayers[Index].CurrentResources.RT_Red
				DisplayTotalRed = round(math.floor(DisplayTotalRed),1)

				PWrap(WinWarning_SetText, "UI_Accumulated_Red"..g_AllPlayers[Index].PlayerIndex, Loc_FormatText2(20050002, g_AllPlayers[Index].DisplayName,  DisplayTotalRed  ))

			else

				PWrapUnsafe(WinWarning_Add, "UI_Accumulated_Red"..g_AllPlayers[Index].PlayerIndex, g_AllPlayers[i].Player, "", "", "" )

			end
			
			PWrapUnsafe(Player_AddResource, g_AllPlayers[Index].Player, RT_Requisition, g_AllPlayers[Index].CurrentAddResources.RT_Requisition * g_WorldTimeFidelity * g_BonusResourcesMultiplier)
			PWrapUnsafe(Player_AddResource, g_AllPlayers[Index].Player, RT_Power, g_AllPlayers[Index].CurrentAddResources.RT_Power * g_WorldTimeFidelity * g_BonusResourcesMultiplier)
			PWrapUnsafe(Player_AddResource, g_AllPlayers[Index].Player, RT_Pop, g_AllPlayers[Index].CurrentAddResources.RT_Pop * g_WorldTimeFidelity * g_BonusResourcesMultiplier)
			PWrapUnsafe(Player_AddResource, g_AllPlayers[Index].Player, RT_Faith, g_AllPlayers[Index].CurrentAddResources.RT_Faith * g_WorldTimeFidelity * g_BonusResourcesMultiplier)
			PWrapUnsafe(Player_AddResource, g_AllPlayers[Index].Player, RT_Souls, g_AllPlayers[Index].CurrentAddResources.RT_Souls * g_WorldTimeFidelity * g_BonusResourcesMultiplier)

			g_AllPlayers[Index].CurrentResources.RT_Red = g_AllPlayers[Index].CurrentResources.RT_Red + g_AllPlayers[Index].CurrentFireCosts.RT_Red
			PWrapUnsafe(Player_AddResource, g_AllPlayers[Index].Player, RT_Requisition, g_AllPlayers[Index].CurrentFireCosts.RT_Requisition )
			PWrapUnsafe(Player_AddResource, g_AllPlayers[Index].Player, RT_Power, g_AllPlayers[Index].CurrentFireCosts.RT_Power )
			PWrapUnsafe(Player_AddResource, g_AllPlayers[Index].Player, RT_Pop, g_AllPlayers[Index].CurrentFireCosts.RT_Pop )
			PWrapUnsafe(Player_AddResource, g_AllPlayers[Index].Player, RT_Faith, g_AllPlayers[Index].CurrentFireCosts.RT_Faith )
			PWrapUnsafe(Player_AddResource, g_AllPlayers[Index].Player, RT_Souls, g_AllPlayers[Index].CurrentFireCosts.RT_Souls )
			g_AllPlayers[Index]:ClearCurrentResourceBonuses()
			
			g_AllPlayers[Index].CurrentResources.RT_Requisition = Player_GetResource(g_AllPlayers[Index].Player, RT_Requisition)
			g_AllPlayers[Index].CurrentResources.RT_Power = Player_GetResource(g_AllPlayers[Index].Player, RT_Power)
			g_AllPlayers[Index].CurrentResources.RT_Pop = Player_GetResource(g_AllPlayers[Index].Player, RT_Pop)
			g_AllPlayers[Index].CurrentResources.RT_Faith = Player_GetResource(g_AllPlayers[Index].Player, RT_Faith)
			g_AllPlayers[Index].CurrentResources.RT_Souls = Player_GetResource(g_AllPlayers[Index].Player, RT_Souls)
			
		else

			PWrap(WinWarning_Remove, "UI_RatioIncomeVsUpkeep_Mixed"..g_AllPlayers[Index].PlayerIndex)

		end

		g_AllPlayers[Index].StatsManager:Update() --This should probably be moved later
		--g_AllPlayers[Index].StatsManager:DebugDumpInfo() --This should probably be moved later

	end

end

--Not online synced!! We should probably never use this... 
function ClearSelection() 

	local g_EmptySGroupID = SGroup_CreateIfNotFound("emptySGroup")
	PWrap(W40k_SelectSGroup, g_EmptySGroupID)
	
end

--R_ENEMY, R_ALLY, R_NEUTRAL, R_UNDEFINED. 
function GetAllPlayerRelationships(_player)

	local own = { _player }
	local allies = {}
	local enemies = {}
	local neutral = {}

	for i = 1, g_PlayerCount do

		local nextPlayer = g_AllPlayers[i].Player

		if(nextPlayer ~= _player.Player) then

			if(Player_IsAlive(nextPlayer)) then

				local tmpRelationship = Player_GetRelationship(_player.Player, nextPlayer)

				if(tmpRelationship == R_ALLY) then

					PWrapUnsafe(table.insert, allies, g_AllPlayers[i])

				elseif(tmpRelationship == R_ENEMY) then

					PWrapUnsafe(table.insert, enemies, g_AllPlayers[i])

				elseif(tmpRelationship == R_NEUTRAL) then

					PWrapUnsafe(table.insert, neutral, g_AllPlayers[i])

				else

					PWrap(Log, eLOG_TYPE_WARNING, eLOG_VERBOSE, "Player: ".._player.DisplayName.." has an undefined relationship with "..nextPlayer.DisplayName)

				end
			end

		end

	end

	return own, allies, enemies, neutral
	
end

