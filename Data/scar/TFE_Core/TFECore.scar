ResourceGroup = {}
function ResourceGroup:new(_RT_Red, _RT_Requsition, _RT_Power, _RT_Pop, _RT_Faith, _RT_Souls)

	AddStacktrace("ResourceGroup:new")

	local ResourceGroupObject = 
	{
		RT_Red = _RT_Red,
	    RT_Requisition = _RT_Requsition,
	    RT_Power =  _RT_Power,
	    RT_Pop =  _RT_Pop,
	    RT_Faith = _RT_Faith, 
	    RT_Souls = _RT_Souls
	}

	self.__index = self

	RemoveStacktrace()

   	return setmetatable(ResourceGroupObject, self)

end

function ResourceGroup:Set(_RT_Red, _RT_Requisition, _RT_Power, _RT_Pop, _RT_Faith, _RT_Souls)

	self.RT_Red = _RT_Red
	self.RT_Requisition = _RT_Requisition
	self.RT_Power = _RT_Power
	self.RT_Pop = _RT_Pop
	self.RT_Faith = _RT_Faith
	self.RT_Souls = _RT_Souls

end

StatsManager = {}
function StatsManager:new (_Parent)

	AddStacktrace("StatsManager:new")

	local StatsManagerObject = 
	{
		--Constants
		Parent = _Parent,

		--Variables
		ActiveArmyCost = ResourceGroup:new(0, 0, 0, 0, 0, 0),
		ResourcesGathered = ResourceGroup:new(0, 0, 0, 0, 0, 0),
		--ResourcesGatheredScore = ResourceGroup:new(0, 0, 0, 0, 0, 0), --Seemingly causes a crash so we can't use this one probably
		ResourcesSpent = ResourceGroup:new(0, 0, 0, 0, 0, 0),
		ResourcesTributed = ResourceGroup:new(0, 0, 0, 0, 0, 0),
		StructuresLost = 0,
		StructuresRazed = 0,
		UnitsKilled = 0,
		LeadersKilled = 0,
		CommandersKilled = 0,
		SquadsKilled = 0,
		UnitsLost = 0,
		LeadersLost = 0,
		CommandersLost = 0,
		SquadsLost = 0,
		HasWon = false

	}

	self.__index = self

	RemoveStacktrace()

   	return setmetatable(StatsManagerObject, self)

end

function StatsManager:Update()
	
	self.ActiveArmyCost:Set(0, Stats_ActiveArmyCost(self.Parent.Player, RT_Requisition), Stats_ActiveArmyCost(self.Parent.Player, RT_Power), Stats_ActiveArmyCost(self.Parent.Player, RT_Pop), 0, 0)
	self.ResourcesGathered:Set(0, Stats_PlayerResGathered(self.Parent.PlayerIndex, RT_Requisition), Stats_PlayerResGathered(self.Parent.PlayerIndex, RT_Power), Stats_PlayerResGathered(self.Parent.PlayerIndex, RT_Pop), 0, 0)
	--self.ResourcesGatheredScore:Set(0, Stats_PlayerResScore(self.Parent.PlayerIndex, RT_Requisition), Stats_PlayerResScore(self.Parent.PlayerIndex, RT_Power), Stats_PlayerResScore(self.Parent.PlayerIndex, RT_Pop), 0, 0)
	self.ResourcesSpent:Set(0, Stats_PlayerResSpent(self.Parent.PlayerIndex, RT_Requisition), Stats_PlayerResSpent(self.Parent.PlayerIndex, RT_Power), Stats_PlayerResSpent(self.Parent.PlayerIndex, RT_Pop), 0, 0)
	self.ResourcesTributed:Set(0, Stats_PlayerResTributed(self.Parent.PlayerIndex, RT_Requisition), Stats_PlayerResTributed(self.Parent.PlayerIndex, RT_Power), Stats_PlayerResTributed(self.Parent.PlayerIndex, RT_Pop), 0, 0)
	--self.StructuresLost = Stats_PlayerStructuresLost(self.Parent.PlayerIndex)
	--self.StructuresRazed = Stats_PlayerStructuresRazed(self.Parent.PlayerIndex)
	--self.UnitsKilled = Stats_PlayerUnitsKilled(self.Parent.PlayerIndex)
	--self.UnitsLost = Stats_PlayerUnitsLost(self.Parent.PlayerIndex)
	self.HasWon = Stats_PlayerWon(self.Parent.PlayerIndex)

end

function StatsManager:DebugDumpInfo()

	AddStacktrace("StatsManager:DebugDumpInfo")

	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Army Cost: Red|"..self.ActiveArmyCost.RT_Red.."  Req|"..self.ActiveArmyCost.RT_Requisition.."  Power|"..self.ActiveArmyCost.RT_Power.."  Pop|"..self.ActiveArmyCost.RT_Pop.."  Faith|"..self.ActiveArmyCost.RT_Faith.."  Souls|"..self.ActiveArmyCost.RT_Souls)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Res Gathered: Red|"..self.ResourcesGathered.RT_Red.."  Req|"..self.ResourcesGathered.RT_Requisition.."  Power|"..self.ResourcesGathered.RT_Power.."  Pop|"..self.ResourcesGathered.RT_Pop.."  Faith|"..self.ResourcesGathered.RT_Faith.."  Souls|"..self.ResourcesGathered.RT_Souls)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Res Gathered Score: Red|"..self.ResourcesGatheredScore.RT_Red.."  Req|"..self.ResourcesGatheredScore.RT_Requisition.."  Power|"..self.ResourcesGatheredScore.RT_Power.."  Pop|"..self.ResourcesGatheredScore.RT_Pop.."  Faith|"..self.ResourcesGatheredScore.RT_Faith.."  Souls|"..self.ResourcesGatheredScore.RT_Souls)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Res Spent: Red|"..self.ResourcesSpent.RT_Red.."  Req|"..self.ResourcesSpent.RT_Requisition.."  Power|"..self.ResourcesSpent.RT_Power.."  Pop|"..self.ResourcesSpent.RT_Pop.."  Faith|"..self.ResourcesSpent.RT_Faith.."  Souls|"..self.ResourcesSpent.RT_Souls)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Res Tributed: Red|"..self.ResourcesTributed.RT_Red.."  Req|"..self.ResourcesTributed.RT_Requisition.."  Power|"..self.ResourcesTributed.RT_Power.."  Pop|"..self.ResourcesTributed.RT_Pop.."  Faith|"..self.ResourcesTributed.RT_Faith.."  Souls|"..self.ResourcesTributed.RT_Souls)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Structures Lost: "..self.StructuresLost)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Structures Razed: "..self.StructuresRazed)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Units Killed: "..self.UnitsKilled)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Leaders Killed: "..self.LeadersKilled)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Commanders Killed: "..self.CommandersKilled)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Squads Killed: "..self.SquadsKilled)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Units Lost: "..self.UnitsLost)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Leaders Lost: "..self.LeadersLost)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Commanders Lost: "..self.CommandersLost)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Squads Lost: "..self.SquadsLost)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Has Won: "..tostring(self.HasWon))

	RemoveStacktrace()

end


RaceDetails = {}
function RaceDetails:new (_RaceName, _RaceIndex, _RaceResourceInfo)

	AddStacktrace("RaceDetails:new")

    local RaceDetailsObject = 
    {
    	--Constants
	    RaceName = _RaceName,
	    RaceIndex = _RaceIndex,
	    RaceResourceInfo = _RaceResourceInfo 
    }

	self.__index = self

	RemoveStacktrace()

   	return setmetatable(RaceDetailsObject, self)
	
end

PlayerDetails = {}
function PlayerDetails:new (_Player, _PlayerIndex, _DisplayName, _RaceDetails)

	AddStacktrace("PlayerDetails:new")

    local PlayerDetailsObject = 
    {
    	--Constants
	    Player = _Player,
	    PlayerIndex = _PlayerIndex,
	    DisplayName = _DisplayName,
	    RaceDetails = _RaceDetails,   	   
		StatsManager = nil,

	    --Variables
		--Is this even being used anymore? just here for future..?
		CurrentResources = 
	    {
			RT_Red = 30,
	    	RT_Requisition = 0,
	    	RT_Power =  0,
	    	RT_Pop =  0,
	    	RT_Faith = 0, 
	    	RT_Souls = 0
	    },

	    CurrentNumberOfResearchedGlobals = 
	    {
			RT_Red = 0,
	    	RT_Requisition = 0,
	    	RT_Power =  0,
	    	RT_Pop =  0,
	    	RT_Faith = 0, 
	    	RT_Souls = 0
	    },
	    
	    CurrentAddResources = 
	    {
			RT_Red = 0,
	    	RT_Requisition = 0,
	    	RT_Power =  0,
	    	RT_Pop =  0,
	    	RT_Faith = 0, 
	    	RT_Souls = 0
	    },
	    
	    CurrentFireCosts = 
	    {
			RT_Red = 0,
	    	RT_Requisition = 0,
	    	RT_Power =  0,
	    	RT_Pop =  0,
	    	RT_Faith = 0, 
	    	RT_Souls = 0
	    }
    }

	PlayerDetailsObject.StatsManager = StatsManager:new(PlayerDetailsObject)

	self.__index = self

	RemoveStacktrace()

	return setmetatable(PlayerDetailsObject, self)

end

function PlayerDetails:AddFireCost( _RT_Red, _RT_Requsition, _RT_Power, _RT_Pop, _RT_Faith, _RT_Souls )

	AddStacktrace("PlayerDetails:AddFireCost")

	self.CurrentFireCosts.RT_Red = self.CurrentFireCosts.RT_Red + _RT_Red
	self.CurrentFireCosts.RT_Requisition = self.CurrentFireCosts.RT_Requisition + _RT_Requsition
	self.CurrentFireCosts.RT_Power = self.CurrentFireCosts.RT_Power + _RT_Power
	self.CurrentFireCosts.RT_Pop = self.CurrentFireCosts.RT_Pop + _RT_Pop
	self.CurrentFireCosts.RT_Faith = self.CurrentFireCosts.RT_Faith + _RT_Faith
	self.CurrentFireCosts.RT_Souls = self.CurrentFireCosts.RT_Souls + _RT_Souls

	RemoveStacktrace()

end

--Returns true if we have enough, false otherwise
function PlayerDetails:HasEnoughResources( _RT_Red, _RT_Requsition, _RT_Power, _RT_Pop, _RT_Faith, _RT_Souls )

	AddStacktrace("PlayerDetails:HasEnoughResources")

	local CostSuccess = true

	if(self.CurrentResources.RT_Red < _RT_Red * -1 
	or self.CurrentResources.RT_Requisition < _RT_Requsition * -1 
	or self.CurrentResources.RT_Power < _RT_Power * -1 
	or self.CurrentResources.RT_Pop < _RT_Pop * -1 
	or self.CurrentResources.RT_Faith < _RT_Faith * -1 
	or self.CurrentResources.RT_Souls < _RT_Souls * -1 ) then
		print("Red: "..self.CurrentResources.RT_Red.."| Required: ".._RT_Red * -1)
		print("Req: "..self.CurrentResources.RT_Requisition.."| Required: ".._RT_Requsition * -1)
		print("Power: "..self.CurrentResources.RT_Power.."| Required: ".._RT_Power * -1)
		print("Pop: "..self.CurrentResources.RT_Pop.."| Required: ".._RT_Pop * -1)
		print("Faith: "..self.CurrentResources.RT_Faith.."| Required: ".._RT_Faith * -1)
		print("Souls: "..self.CurrentResources.RT_Souls.."| Required: ".._RT_Souls * -1)
		CostSuccess = false
	end	
	
	RemoveStacktrace()

	return CostSuccess

end

function PlayerDetails:ClearCurrentResourceBonuses()

	AddStacktrace("PlayerDetails:ClearCurrentResourceBonuses")

	self.CurrentAddResources = 
    {
	    RT_Requisition = 0,
	    RT_Power =  0,
	    RT_Pop =  0,
	    RT_Faith = 0, 
		RT_Souls = 0,
		RT_Red = 0
	}

	self.CurrentFireCosts = 
	{
	    RT_Requisition = 0,
	    RT_Power =  0,
	    RT_Pop =  0,
	    RT_Faith = 0, 
	    RT_Souls = 0,
		RT_Red = 0
	 }

	 RemoveStacktrace()

end


import("TFE_Core/Imports/TFECore_Imports.scar")


function Core_Game_Load()

	AddStacktrace("Core_Game_Load")	
	
	DoBasicFunction(Core_CheckForSecondaryScars)
	Rule_AddInterval(Core_MainLoop, g_WorldTimeFidelity)

	RemoveStacktrace()
	
end

function Core_Init_Load()

	AddStacktrace("Core_Init_Load")
	Core_GetAllPlayers()
	--if(DoCriticalFunction(Core_GetAllPlayers) == false) then return false end
	if(DoBasicFunction(Setup_AlphaLegion) == false) then Log(2, 0, debug_TFECore_FileName, debugFuncName, "Alpha Legion failed to setup!") end
	if(DoCriticalFunction(Setup_PassiveResourceGeneration) == false) then return false end
	if(DoCriticalFunction(Setup_EntityManager) == false) then return false end
	if(DoCriticalFunction(Setup_SquadManager) == false) then return false end
	if(DoCriticalFunction(Setup_GlobalsStorage) == false) then return false end
	if(DoCriticalFunction(Setup_StrategicPoints) == false) then return false end
	if(DoCriticalFunction(Setup_MatureSystem) == false) then return false end
	if(DoCriticalFunction(Setup_UpkeepSystem) == false) then return false end
	if(DoCriticalFunction(Setup_NewCoverSystem) == false) then return false end
	DoBasicFunction(Setup_WeatherSystems)
	DoBasicFunction(Setup_GlobalAbilities)
	--DoBasicFunction(Setup_Achievements)
	Setup_Achievements()

	RemoveStacktrace()

	return true	

end

function Core_CheckForSecondaryScars()

	AddStacktrace("Core_CheckForSecondaryScars")
	
	if g_TrueRandomRace_Enabled == true then

		TrueRandomRace_Setup()
	
	end

	RemoveStacktrace()

end

function Core_GetAllPlayers()
		
	AddStacktrace("Core_GetAllPlayers")

	for i = 1, g_PlayerCount do

		local Player = World_GetPlayerAt(i-1)
		local PlayerIndex = World_GetPlayerIndex(Player)
		local RaceName = Player_GetRaceName( Player ) 
		local RaceIndex = Player_GetRace( Player ) 
		local DisplayName = Player_GetDisplayName(Player)

		Setup_PassiveResourceGeneration_Settings(RaceName)
		table.insert(g_AllPlayers, PlayerDetails:new( Player, PlayerIndex, DisplayName, RaceDetails:new (RaceName, RaceIndex, g_FactionSpecificResourceGeneration[RaceName] )))

		--Move this later
		if (UnitCosting[RaceName] == nil) then

			pcall(import, 'upkeep/races/'..RaceName..'.scar')

		end
		
	end

	for i = 1, g_PlayerCount do
		
		--They need to be in reverse order so P1 is on top...
		WinWarning_Add( "UI_RatioIncomeVsUpkeep_Mixed"..g_AllPlayers[g_PlayerCount-i+1].PlayerIndex, g_AllPlayers[g_PlayerCount-i+1].Player, "", "Mature and Upkeep Counter", "This counter shows the specified players mature and upkeep." )
		WinWarning_Add( "UI_Accumulated_Red"..g_AllPlayers[g_PlayerCount-i+1].PlayerIndex, g_AllPlayers[g_PlayerCount-i+1].Player, "", "Red Counter", "This counter shows the ammount of gathered red for the player." )

	end

	RemoveStacktrace()

end

function DoCriticalFunction(_Func)

	AddStacktrace("DoCriticalFunction")

	local Success = true

	if(pcall(_Func) == false) then
		 
		LogError("Cannot run CRITICAL function!") 
		
		Success = false

	end

	RemoveStacktrace()

	return Success

end


function DoBasicFunction(_Func)
	
	AddStacktrace("DoBasicFunction")

	local Success = true

	if(pcall(_Func) == false) then

		Log(eLOG_LOG_TYPE_ERROR, eLOG_FULL, "Cannot run function!") 

		Success = false

	end

	RemoveStacktrace()

	return Success

end

function Core_MainLoop()
	
	AddStacktrace("Core_MainLoop")

	if(DoCriticalFunction(Set_UpdatedGameTime) == false) then return end
	if(DoCriticalFunction(Set_AllSquads_Immediate) == false) then return end
	if(DoCriticalFunction(Set_AllEntities_Immediate) == false) then return end
	if(DoCriticalFunction(Set_AllSquadCoverModifiers) == false) then return end
	if(DoCriticalFunction(Set_PlayerUpkeep, debug_TFECore_FileName) == false) then return end 
	if(DoCriticalFunction(Set_ResourceMature, debug_TFECore_FileName) == false) then return end
	--if(DoCriticalFunction(Implement_UpkeepAndMature, debug_TFECore_FileName) == false) then return end
	Implement_UpkeepAndMature()
	DoBasicFunction(Set_Weather)
	DoBasicFunction(Update_GlobalAbilities)
	--DoBasicFunction(Update_Achievements)
	Update_Achievements()

	RemoveStacktrace()
	
end

function ErrorPause()

	AddStacktrace("ErrorPause")

	g_ModRunning = false
	Rule_RemoveAll()

	RemoveStacktrace()

end

function Implement_UpkeepAndMature()

	AddStacktrace("Implement_UpkeepAndMature")
	
	for i = 1, g_PlayerCount do
		local Index = g_PlayerCount - i +1
		--They need to be in reverse order so P1 is on top...
		if(Player_IsAlive(g_AllPlayers[Index].Player)) then

			if(WinWarning_Exists("UI_RatioIncomeVsUpkeep_Mixed"..g_AllPlayers[Index].PlayerIndex)) then
				
				local DisplayReqIncome = g_AllPlayers[Index].CurrentAddResources.RT_Requisition				
				local DisplayPowerIncome = g_AllPlayers[Index].CurrentAddResources.RT_Power 
				DisplayReqIncome = round(math.floor(DisplayReqIncome),2)
				DisplayPowerIncome = round(math.floor(DisplayPowerIncome),2)

				WinWarning_SetText( "UI_RatioIncomeVsUpkeep_Mixed"..g_AllPlayers[Index].PlayerIndex, Loc_FormatText3( 20050000, g_AllPlayers[Index].DisplayName,  DisplayReqIncome , DisplayPowerIncome ))
			else

				WinWarning_Add( "UI_RatioIncomeVsUpkeep_Mixed"..g_AllPlayers[Index].PlayerIndex, g_AllPlayers[i].Player, "", "", "" )

			end

			if(WinWarning_Exists("UI_Accumulated_Red"..g_AllPlayers[Index].PlayerIndex)) then
				
				local DisplayTotalRed = g_AllPlayers[Index].CurrentResources.RT_Red
				DisplayTotalRed = round(math.floor(DisplayTotalRed),1)

				WinWarning_SetText( "UI_Accumulated_Red"..g_AllPlayers[Index].PlayerIndex, Loc_FormatText2( 20050002, g_AllPlayers[Index].DisplayName,  DisplayTotalRed  ))

			else

				WinWarning_Add( "UI_Accumulated_Red"..g_AllPlayers[Index].PlayerIndex, g_AllPlayers[i].Player, "", "", "" )

			end
			

			Player_AddResource(g_AllPlayers[Index].Player, RT_Requisition, g_AllPlayers[Index].CurrentAddResources.RT_Requisition * g_WorldTimeFidelity * g_BonusResourcesMultiplier)
			Player_AddResource(g_AllPlayers[Index].Player, RT_Power, g_AllPlayers[Index].CurrentAddResources.RT_Power * g_WorldTimeFidelity * g_BonusResourcesMultiplier)
			Player_AddResource(g_AllPlayers[Index].Player, RT_Pop, g_AllPlayers[Index].CurrentAddResources.RT_Pop * g_WorldTimeFidelity * g_BonusResourcesMultiplier)
			Player_AddResource(g_AllPlayers[Index].Player, RT_Faith, g_AllPlayers[Index].CurrentAddResources.RT_Faith * g_WorldTimeFidelity * g_BonusResourcesMultiplier)
			Player_AddResource(g_AllPlayers[Index].Player, RT_Souls, g_AllPlayers[Index].CurrentAddResources.RT_Souls * g_WorldTimeFidelity * g_BonusResourcesMultiplier)

			g_AllPlayers[Index].CurrentResources.RT_Red = g_AllPlayers[Index].CurrentResources.RT_Red + g_AllPlayers[Index].CurrentFireCosts.RT_Red
			Player_AddResource(g_AllPlayers[Index].Player, RT_Requisition, g_AllPlayers[Index].CurrentFireCosts.RT_Requisition )
			Player_AddResource(g_AllPlayers[Index].Player, RT_Power, g_AllPlayers[Index].CurrentFireCosts.RT_Power )
			Player_AddResource(g_AllPlayers[Index].Player, RT_Pop, g_AllPlayers[Index].CurrentFireCosts.RT_Pop )
			Player_AddResource(g_AllPlayers[Index].Player, RT_Faith, g_AllPlayers[Index].CurrentFireCosts.RT_Faith )
			Player_AddResource(g_AllPlayers[Index].Player, RT_Souls, g_AllPlayers[Index].CurrentFireCosts.RT_Souls )
			g_AllPlayers[Index]:ClearCurrentResourceBonuses()
			
			g_AllPlayers[Index].CurrentResources.RT_Requisition = Player_GetResource(g_AllPlayers[Index].Player, RT_Requisition)
			g_AllPlayers[Index].CurrentResources.RT_Power = Player_GetResource(g_AllPlayers[Index].Player, RT_Power)
			g_AllPlayers[Index].CurrentResources.RT_Pop = Player_GetResource(g_AllPlayers[Index].Player, RT_Pop)
			g_AllPlayers[Index].CurrentResources.RT_Faith = Player_GetResource(g_AllPlayers[Index].Player, RT_Faith)
			g_AllPlayers[Index].CurrentResources.RT_Souls = Player_GetResource(g_AllPlayers[Index].Player, RT_Souls)
		else

			WinWarning_Remove("UI_RatioIncomeVsUpkeep_Mixed"..g_AllPlayers[Index].PlayerIndex)

		end

		g_AllPlayers[Index].StatsManager:Update() --This should probably be moved later
		--g_AllPlayers[Index].StatsManager:DebugDumpInfo() --This should probably be moved later

	end
	
	RemoveStacktrace()

end

--Not online synced!! We should probably never use this... 
function ClearSelection() 

	AddStacktrace("ClearSelection")

	local g_EmptySGroupID = SGroup_CreateIfNotFound("emptySGroup")
	W40k_SelectSGroup(g_EmptySGroupID)
	
	RemoveStacktrace()

end

--R_ENEMY, R_ALLY, R_NEUTRAL, R_UNDEFINED. 
function GetAllPlayerRelationships(_player)

	AddStacktrace("GetAllPlayerRelationships")

	local own = { _player }
	local allies = {}
	local enemies = {}
	local neutral = {}

	for i = 1, g_PlayerCount do

		local nextPlayer = g_AllPlayers[i].Player

		if(nextPlayer ~= _player.Player) then

			if(Player_IsAlive(nextPlayer)) then

				local tmpRelationship = Player_GetRelationship(_player.Player, nextPlayer)

				if(tmpRelationship == R_ALLY) then

					table.insert(allies, g_AllPlayers[i])

				elseif(tmpRelationship == R_ENEMY) then

					table.insert(enemies, g_AllPlayers[i])

				elseif(tmpRelationship == R_NEUTRAL) then

					table.insert(neutral, g_AllPlayers[i])

				else

					Log(eLOG_TYPE_WARNING, eLOG_VERBOSE, "Player: ".._player.DisplayName.." has an undefined relationship with "..nextPlayer.DisplayName)

				end
			end

		end

	end

	
	RemoveStacktrace()

	return own, allies, enemies, neutral
	
end

