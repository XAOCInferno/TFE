--Log Type ENUMS
eLOG_TYPE_INFO = 0
eLOG_LOG_TYPE_WARNING = 1
eLOG_LOG_TYPE_ERROR = 2
eLOG_LOG_TYPE_CRITICAL = 3

--Verbosity ENUMS
eLOG_FULL = 0
eLOG_VERBOSE = 1
eLOG_SIMPLE = 2
eLOG_MOD_ONLY = 3
eLOG_NONE = 4

local LogTypes = {}
LogTypes[0] = "i" --Basic Log
LogTypes[1] = "?" --Concern / Warning
LogTypes[2] = "!!" --Basic Error
LogTypes[3] = "!!!!" --Severe Error
local LogTypesLength = table.getn(LogTypes)

local WrittenLogs = {}

local StacktracePath = "@"
local StacktraceStack = {}

local function GetLogType(_LogType)

	local ReturnValue = "nil"

	if(_LogType > LogTypesLength) then

		PWrap(Log, eLOG_SIMPLE, eLOG_LOG_TYPE_WARNING, "Log type of '".._LogType.."' is invalid! Number must be bellow "..LogTypesLength)

	else

		ReturnValue = LogTypes[_LogType]

	end
	
	return ReturnValue

end

local function GetFuncName(func)

	for i,v in pairs(getfenv()) do
		
		if v == func then
			
			return i

		end

	end

end

--P standing for PCall
--func is required. Other args are optional.
local function PWrapInternal( safe, removeProtections, func, a, b, c, d, e, f, g, h, i, j, k, m, n, l, o, p, q, r, s, t, u, v, w, x, y, z )
	
	if func == nil then
		
		Log(eLOG_LOG_TYPE_ERROR, eLOG_FULL, "Function is not defined! Cannot be wrapped.")
		return

	end

	local function WrappedFunction() 
		
		return func(a, b, c, d, e, f, g, h, i, j, k, m, n, l, o, p, q, r, s, t, u, v, w, x, y, z) 
	
	end

	local funcName = GetFuncName(func)

	AddStacktrace2(funcName or "?")

	if(removeProtections) then 

		WrappedFunction()

	else

		Success = pcall(WrappedFunction)

	end

	if Success == false then 

		LogPWrapedError( safe, a, b, c, d, e, f, g, h, i, j, k, m, n, l, o, p, q, r, s, t, u, v, w, x, y, z)

	end

	RemoveStacktrace2()

	return Success

end


--Do if arguments are concatable
function PWrap( func, a, b, c, d, e, f, g, h, i, j, k, m, n, l, o, p, q, r, s, t, u, v, w, x, y, z )

	return PWrapInternal(true, false, func, a, b, c, d, e, f, g, h, i, j, k, m, n, l, o, p, q, r, s, t, u, v, w, x, y, z)

end

--Do if arguments aren't concatable (functions, tables..)
function PWrapUnsafe( func, a, b, c, d, e, f, g, h, i, j, k, m, n, l, o, p, q, r, s, t, u, v, w, x, y, z )

	return PWrapInternal(false, false, func, a, b, c, d, e, f, g, h, i, j, k, m, n, l, o, p, q, r, s, t, u, v, w, x, y, z)

end


--Override PWrap if we're playing in unsafe mode
function DebugDisableCodeProtections()

	Log(eLOG_LOG_TYPE_WARNING, eLOG_FULL, "Disabling code protections, this should not happen in shipped mod.") 

	--Do if arguments are concatable
	function PWrap( func, a, b, c, d, e, f, g, h, i, j, k, m, n, l, o, p, q, r, s, t, u, v, w, x, y, z )

		return PWrapInternal(true, true, func, a, b, c, d, e, f, g, h, i, j, k, m, n, l, o, p, q, r, s, t, u, v, w, x, y, z)

	end

	--Do if arguments aren't concatable (functions, tables..)
	function PWrapUnsafe( func, a, b, c, d, e, f, g, h, i, j, k, m, n, l, o, p, q, r, s, t, u, v, w, x, y, z )

		return PWrapInternal(false, true, func, a, b, c, d, e, f, g, h, i, j, k, m, n, l, o, p, q, r, s, t, u, v, w, x, y, z)

	end
	
end


--Refers back to PWrap, pottential infinite loop & stack overflow be careful
function LogPWrapedError(safe, a, b, c, d, e, f, g, h, i, j, k, m, n, l, o, p, q, r, s, t, u, v, w, x, y, z)

	local ErrorMessage = "<-ERROR! Args: "

	local function AddArgs()

		if safe then
		
			ErrorMessage = ErrorMessage..a or "".."  "..b or "".."  "..c or "".."  "..d or "".."  "..e or "".."  "..f or "".."  "..g or "".."  "..h or "".."  "..i or "".."  "..j or "".."  "..k or "".."  "..m or "".."  "..n or "".."  "..l or "".."  "..o or "".."  "..p or "".."  "..q or "".."  "..r or "".."  "..s or "".."  "..t or "".."  "..u or "".."  "..v or "".."  "..w or "".."  "..x or "".."  "..y or "".."  "..z or ""
	
		end

	end

	if pcall(AddArgs) == false then

		ErrorMessage = ErrorMessage.."Invalid Args."

	end

	PWrap(Log, eLOG_FULL, eLOG_LOG_TYPE_ERROR, ErrorMessage)

end

function AddStacktrace(_FunctionName)


end

function RemoveStacktrace()


end

--Do not PWrap, stack overflow.
function AddStacktrace2(_FunctionName)

	table.insert(StacktraceStack, _FunctionName)

end

--Do not PWrap, stack overflow.
function RemoveStacktrace2()

	table.remove(StacktraceStack, table.getn(StacktraceStack))

end

function ClearStacktrace()

	StacktracePath = "@"
	StacktraceStack = {}

end

--[[Get the full path as a string]]
local function SetStacktracePath(_Verbosity)

	StacktracePath = "@"
	if(_Verbosity == eLOG_FULL) then

		for i = 1, table.getn(StacktraceStack) do

			StacktracePath = StacktracePath.."/"..StacktraceStack[i]

		end

		StacktracePath = StacktracePath.."\n"

	elseif(_Verbosity == eLOG_VERBOSE) then

		local StacktraceStackLength = table.getn(StacktraceStack)
		
		for i = StacktraceStackLength-4, StacktraceStackLength-2 do

			if (i > 0) then

				StacktracePath = StacktracePath.."/"..StacktraceStack[i]

			end

		end

		StacktracePath = StacktracePath.."\n"

	else

		StacktracePath = ""

	end

end

--Writes a custom log to the console
function Log(_LogType, _Verbosity, _Line)
	
	_Verbosity = _Verbosity or eLOG_VERBOSE
	_Line = _Line or "[[NO MESSAGE]]"

	PWrap(SetStacktracePath, _Verbosity)

	if(_Verbosity == eLOG_NONE) then

		print(" | \v  ".._Line.." |")

	elseif(_Verbosity == eLOG_MOD_ONLY) then
		
		print(" | \v  ["..g_ModAbbreviation.."] ".._Line.." |")

	elseif(_Verbosity == eLOG_SIMPLE) then
		
		print(" | \v  ("..GetLogType(_LogType)..") ["..g_ModAbbreviation.."] ".._Line.." |")

	elseif(_Verbosity == eLOG_VERBOSE) then
		
		print(" | \v  ("..GetLogType(_LogType)..") ["..g_ModAbbreviation.."] ("..g_WorldTime.."s) ".._Line.." |")

	elseif(_Verbosity == eLOG_FULL) then

		--Avoid using eLOG_FULL for simple logs as stacktrace takes up a lot of the console
		print(" \n[[\n\v  ("..GetLogType(_LogType)..") ["..g_ModAbbreviation.."] ("..g_WorldTime.."s)\n\v  ".._Line.."\n\v "..StacktracePath.."]]")

	else	
		
		--Be careful of stack overflow here, should consider a way of calculating this and avoiding it.
		Log(eLOG_LOG_TYPE_ERROR, eLOG_VERBOSE, "[[Invalid Log Type Of: ".._Verbosity.."]]".._Line)	
	
	end

end

local TableContainsOverride = function(_Tbl, _Desired)

	local ReturnIndex = 0
	local Success = false

	if(_Tbl ~= nil) then 

		for index, item in pairs (_Tbl) do

	    	if(item == _Desired) then

				Success = true
				ReturnIndex = index
				break

	    	end

		end

	else	

		Log(eLOG_LOG_TYPE_WARNING, eLOG_FULL, "Table is nil, returning false as default.")

	end

	return Success, ReturnIndex

end

--Writes a custom log to the console, if it hasn't been written before
function LogOnce(_LogType, _Verbosity, _Line)
	
	PWrap(SetStacktracePath, _Verbosity)

	local LogID = StacktracePath.._Line
	contains, _ = TableContainsOverride(WrittenLogs, LogID)

	if(contains == false) then

		PWrap(table.insert, WrittenLogs, LogID)
		PWrap(Log, _LogType, _Verbosity, _Line)

	end
	
end

function LogError(_Line)
	
	g_DebugMode = true --Error is so severe we should force debug on!
	PWrap(UIWarning_Show, "--------------------------------------------\n------TFE CORE FATAL ERROR------\n-----------CORE STOPPED------------\n--------------------------------------------" )
	PWrap(Log, eLOG_LOG_TYPE_CRITICAL, eLOG_FULL, _Line)
	PWrap(Log, eLOG_LOG_TYPE_WARNING, eLOG_NONE, "|")
	PWrap(Log, eLOG_LOG_TYPE_WARNING, eLOG_NONE, "--------------------------------------------")
	PWrap(Log, eLOG_LOG_TYPE_WARNING, eLOG_NONE, "------TFE CORE FATAL ERROR------")
	PWrap(Log, eLOG_LOG_TYPE_WARNING, eLOG_NONE, "-----------CORE STOPPED------------")
	PWrap(Log, eLOG_LOG_TYPE_WARNING, eLOG_NONE, "--------------------------------------------")
	PWrap(Log, eLOG_LOG_TYPE_WARNING, eLOG_NONE, "|")
	PWrap(ErrorPause)

end

--This function will do something illegal that should warrant game to crash
--Good to use this to check for thoroughness of error checking
function DoFatalError()

	--Ensure this is not PWrapped!
	print(""..{}.."")

end