---------
--DEBUG--
---------
debug_SquadManager_FileName = "SquadManager_Core.scar"

----------------------
--Class Constructors--
----------------------
StrategicPoint = {}
function StrategicPoint:new (_ID, _OwnedBy, _InitTime)

    local StrategicPointObject = 
    {
	    ID = _ID,
	    OwnedBy = _OwnedBy,
	    InitTime = _InitTime
    }
	self.__index = self
    return setmetatable(StrategicPointObject, self)
end


SquadData = {}
function SquadData:new (_sGameID, _sGroupID, _sIndex, _sID, _sRace, _sBP, _player)
	local tmpSGroupID = GetUniqueSG("SquadData")
	local tmpSGroupName = SGroup_GetName(tmpSGroupID)
	SGroup_Add(tmpSGroupID, _sID)
    local SquadDataObject = 
    {
		SquadUniqueID = _sGameID,	
		SquadGroupID = tmpSGroupID,
		SquadGroupName = tmpSGroupName,	
		SquadIndex = _sIndex, 
		SquadID = _sID,	
		SquadUnitRace = _sRace,
		SquadBlueprint = _sBP,
		SquadLoadout = Squad_Count(_sID),
		SquadHasLeader = Squad_HasLeader(_sID),
		SquadLeaderCount = Squad_CountLeaders(_sID),
		SquadInitTime = g_WorldTime,	
		SquadPosition = Squad_GetPosition(_sID),
		OwnedByPlayer = Squad_GetPlayerOwner(_sID), --Duplicate functionality as bellow? I would prefere we kept this one
		OwnerPlayer = _player, --Um do we need this./.???
		IsSelected_Unsynced = Misc_IsSquadSelected(_sID),

		SquadAppliedCoverMods = {},
		SquadAppliedCoverMods_IDs = {},
		SquadAppliedCoverMods_Index = {},

		--Variables
		IsUnderAttack = false,
		PreviousSquadLoadout = Squad_Count(_sID),
		PreviousSquadLeaderCount = Squad_CountLeaders(_sID),
		PreviouslyAttackedByPlayers = {},
		PreviouslyAttackedTime = 0
	}
	self.__index = self
	return setmetatable(SquadDataObject, self)
end

function SquadData:Update(_self)
		
	_self.SquadLoadout = Squad_Count(_self.SquadID)
	_self.SquadHasLeader = Squad_HasLeader(_self.SquadID)
	_self.SquadLeaderCount = Squad_CountLeaders(_self.SquadID)
	_self.SquadPosition = Squad_GetPosition(_self.SquadID)
	_self.OwnedByPlayer = Squad_GetPlayerOwner(_self.SquadID)
	_self.IsSelected_Unsynced = Misc_IsSquadSelected(_self.SquadID)

end

---------------
--Main Script--
---------------
function Setup_SquadManager()
	
	Set_AllSquads_Immediate()

end

function Set_AllSquads_Immediate()
	
	for i = 1, g_PlayerCount do
		
		Set_PlayerSquads_Immediate(i)
		
	end

end

function Set_PlayerSquads_Immediate(_PlayerIndex)	
	local debugFuncName = "UpdatePlayerSquads_Immediate"
	
	--We should only run the squad checker if the player is alive
	if (not Player_IsAlive(g_AllPlayers[_PlayerIndex].Player)) then			
		return nil					
	end
				
	local AddSGroupData = function(_sgroupid, _itemindex, _squadID)
		
		local newSquadGameID = Squad_GetGameID( _squadID )
		local squadBP = Squad_GetBlueprintName( _squadID )			
		
		if(TableContains(g_SquadBlueprintToIgnore, squadBP)) then return false end

		if(squadBP == nil) then 

			LogOnce(1, 0, debug_SquadManager_FileName, debugFuncName, "Can't add squad data, BP is nil!")
			return 

		end
		
		for l = 1, TableLength(g_AllSquadsData[_PlayerIndex]) do

			if(g_AllSquadsData[_PlayerIndex][l] == nil) then

				table.remove(g_AllSquadsData[_PlayerIndex], l)	
				--I don't think we need to return here?
				--return false

			end
			
			if(g_AllSquadsData[_PlayerIndex][l].SquadUniqueID == newSquadGameID) then
						
				return false
										
			end
		end		
			
		--Might need to create a unique sgroupid later...
		local tmpData = SquadData:new( newSquadGameID, _sgroupid, _itemindex, _squadID, g_AllPlayers[_PlayerIndex].RaceDetails.RaceName, squadBP, g_AllPlayers[_PlayerIndex])
		table.insert(g_AllSquadsData[_PlayerIndex], tmpData)	
			
	end

	Update_ExistingSquadDetails()		
	SGroup_ForEachEx(Player_GetSquads(g_AllPlayers[_PlayerIndex].Player), AddSGroupData, true, false)				
	
	for k = 1, TableLength(g_AllSquadsData[_PlayerIndex]) do
		if(g_AllSquadsData[_PlayerIndex][k] ~= nil) then
			
			local shouldIgnore, _ = TableContains(g_SquadBlueprintToIgnore, g_AllSquadsData[_PlayerIndex][k].SquadBlueprint)
			if(g_AllSquadsData[_PlayerIndex][k].SquadBlueprint == nil or g_AllSquadsData[_PlayerIndex][k].SquadLoadout == 0 or shouldIgnore) then

				table.remove(g_AllSquadsData[_PlayerIndex], k)
				
			end
		end
	end
		
	g_PlayerSquadCount[_PlayerIndex] = Player_GetActiveSquadCount(g_AllPlayers[_PlayerIndex].Player)
		
end

function Update_ExistingSquadDetails()
	for i = 1, g_PlayerCount do
		for l = 1, TableLength(g_AllSquadsData[i]) do

			--Simple check to avoid null ref
			if(g_AllSquadsData[i][l] == nil) then

				table.remove(g_AllSquadsData[i], l)	


			--Squad has been destroyed since our last check, so we grant red resource.
			elseif(Squad_Exists(g_AllSquadsData[i][l].SquadUniqueID) == false) then	--Does this work?
				
				Set_SquadCombatDetails(g_AllSquadsData[i][l], true)	
				g_AllSquadsData[i][l].SquadHasPreviouslyExisted = true
				table.remove(g_AllSquadsData[i], l)							
			
			--Squad exists and has more than 0 members so let's update their squad details.
			else						
				g_AllSquadsData[i][l]:Update(g_AllSquadsData[i][l])
				--[[g_AllSquadsData[i][l].SquadLoadout = Squad_Count(g_AllSquadsData[i][l].SquadID)
				g_AllSquadsData[i][l].SquadHasLeader = Squad_HasLeader(g_AllSquadsData[i][l].SquadID)
				g_AllSquadsData[i][l].SquadLeaderCount = Squad_CountLeaders(g_AllSquadsData[i][l].SquadID)]]
				Set_SquadCombatDetails(g_AllSquadsData[i][l], false)		

				--Squad exists but now has 0 members. At 0 members the squad is destroyed so this likely will never happen. If log isn't ever observed, delete this.
				if(g_AllSquadsData[i][l].SquadLoadout == 0 and g_AllSquadsData[i][l].SquadHasPreviouslyExisted == true) then

					Log(1, 0, debug_SquadManager_FileName, "Update_ExistingSquadDetails", "Squad has been destroyed but squad still exists?")	
					Set_SquadCombatDetails(g_AllSquadsData[i][l], true)			
					table.remove(g_AllSquadsData[i],l)	

				else
					--Squad is alive and we update their combat status to look for dead members etc
					Set_SquadCombatDetails(g_AllSquadsData[i][l], false)

				end
			end

		end		
	end
end

function CheckForSquadLosses(SquadStruct)

	local Losses = 0
	local LeaderLosses = 0
	
	if(SquadStruct.PreviousSquadLoadout > SquadStruct.SquadLoadout) then

		Losses = SquadStruct.PreviousSquadLoadout - SquadStruct.SquadLoadout

	end
	
	if(SquadStruct.PreviousSquadLeaderCount > SquadStruct.SquadLeaderCount) then

		LeaderLosses = SquadStruct.PreviousSquadLeaderCount - SquadStruct.SquadLeaderCount

	end

	SquadStruct.PreviousSquadLoadout = SquadStruct.SquadLoadout
	SquadStruct.PreviousSquadLeaderCount = SquadStruct.SquadLeaderCount

	return Losses, LeaderLosses

end

--Use 1 or 0 for SquadDead with 0 being false and 1 being true
function UpdateSquadCombatDeathResources(RedReceiverPlayer, DefenderPlayer, ModelLosses, LeaderLosses, SquadDead ) 

	local TotalRed = 0
	TotalRed = TotalRed + (0.5 * ModelLosses)
	TotalRed = TotalRed + (1.5 * LeaderLosses)
	TotalRed = TotalRed + (3 * SquadDead)
	TotalRed = TotalRed * g_RedGainMultiplier

	RedReceiverPlayer.CurrentResources.RT_Red = RedReceiverPlayer.CurrentResources.RT_Red + TotalRed	
	print("Player "..RedReceiverPlayer.PlayerIndex.." current Red = "..RedReceiverPlayer.CurrentResources.RT_Red)

	DefenderPlayer.CurrentResources.RT_Red = DefenderPlayer.CurrentResources.RT_Red + (TotalRed * 0.5)	
	print("Player "..DefenderPlayer.PlayerIndex.." current Red = "..DefenderPlayer.CurrentResources.RT_Red)

end

function Get_SquadLosses(_SquadStruct)

	return _SquadStruct.PreviousSquadLoadout - _SquadStruct.SquadLoadout, _SquadStruct.SquadLeaderCount - _SquadStruct.PreviousSquadLeaderCount

end

function Set_SquadCombatDetails(_SquadStruct, _IsDead)
	local ModelLosses = 0
	local LeaderLosses = 0
	local SquadDeath = 0

	--Squad is dead. Time to give big reward to killers...
	if(_IsDead) then

		local AttackerPlayerLength = table.getn(_SquadStruct.PreviouslyAttackedByPlayers) or 0
		if(AttackerPlayerLength == 0) then
			Log(1, 0, debug_SquadManager_FileName, "Set_SquadCombatDetails", "No players have fought this squad, so who killed it?")	
			return
		end

		for i = 1, AttackerPlayerLength do

			ModelLosses, LeaderLosses = Get_SquadLosses(_SquadStruct)
			print("Squad destroyed! Adding large Red for Player ".._SquadStruct.PreviouslyAttackedByPlayers[i].PlayerIndex..".")
			UpdateSquadCombatDeathResources(_SquadStruct.PreviouslyAttackedByPlayers[i], _SquadStruct.OwnerPlayer, ModelLosses, LeaderLosses, 1 )

		end

		return

	end

	--Squad is still alive so we need to calculate who is fighting them
	if(Squad_IsUnderAttack(_SquadStruct.SquadID)) then
			
		local PlayersToRemove = {}
		for i = 1, g_PlayerCount do
			
			if(Squad_IsUnderAttackByPlayer(_SquadStruct.SquadID, g_AllPlayers[i].Player)) then
				
				local contains, _  = TableContains(_SquadStruct.PreviouslyAttackedByPlayers, g_AllPlayers[i])
				if(contains == false) then

					table.insert(_SquadStruct.PreviouslyAttackedByPlayers, g_AllPlayers[i])

				end

				ModelLosses, LeaderLosses = CheckForSquadLosses(_SquadStruct)
				if(ModelLosses > 0 or LeaderLosses > 0) then

					UpdateSquadCombatDeathResources(g_AllPlayers[i], _SquadStruct.OwnerPlayer, ModelLosses, LeaderLosses, 0 )		
					print("Adding Red for Player "..g_AllPlayers[i].PlayerIndex..".")					
	
				end	
			
			else

				--We don't know who attacked? we should calculate a player here based on distance perhaps, or just assign to assassin who is only one we know can do this.
				table.insert(PlayersToRemove, g_AllPlayers[i])

			end			

		end

		_SquadStruct.PreviouslyAttackedByPlayers = TableRemoveDuplicates(_SquadStruct.PreviouslyAttackedByPlayers, PlayersToRemove)

	--It's been quite a long time since we've been in a fight so we shouldn't remember last fighting players, especially as we can be scuttled.
	elseif(g_WorldTime - _SquadStruct.PreviouslyAttackedTime > 5) then
		
		_SquadStruct.PreviouslyAttackedByPlayers = {}

	end


end

function GetAllSelectedSquads()
	
	local allSelectedSquads = {}

	for playerIndex = 1, g_AllSquadsData do

		for squadIndex = 1, g_AllSquadsData[playerIndex] do

			if(g_AllSquadsData[playerIndex][squadIndex].IsSelected == true) then

				table.insert(allSelectedSquads, g_AllSquadsData[playerIndex][squadIndex])

			end

		end

	end

	return allSelectedSquads
	
end

function GetIfSquadSelected(_DesiredSquad)

	local AllSelectedSquads = GetAllSelectedSquads()
	local contains, _ = TableContains(AllSelectedSquads, _DesiredSquad)

	if(contains == true) then
		return true
	end

	return false
end

--Use for AoE 
function GetAllSquadsInArea(_player, _pos, _proximity)
	
	SquadsInRange = {}
	for i = 1, g_PlayerSquadCount[_player] do
		if(World_DistancePointToPoint(_pos, g_AllSquadsData[_player][i].SquadPosition) <= _proximity) then
			print(g_AllSquadsData[_player][i].SquadBlueprint.." Is in range.")
			table.insert(SquadsInRange, g_AllSquadsData[_player][i])
		end
	end

end

--Use for AoE 
function GetAllSquadsInAreaFromPlayerTable(_players, _pos, _proximity)
	
	SquadsInRange = {}
	for j = 1, TableLength(_players) do
		for i = 1, g_PlayerSquadCount[j] do
			if(World_DistancePointToPoint(_pos, g_AllSquadsData[j][i].SquadPosition) <= _proximity) then
				print(g_AllSquadsData[j][i].SquadBlueprint.." Is in range.")
				table.insert(SquadsInRange, g_AllSquadsData[j][i])
			end
		end
	end

end

--Use for single target
function GetClosestSquadToPos(_player, _pos, _maxDistance)

	local debugFuncName = "GetClosestSquadToPos"	

	if(TableLength(g_PlayerSquadCount[_player]) == 0) then

		Log(1, 0, debug_SquadManager_FileName, debugFuncName, "No squads are near that position as player has no squads.")
		return nil
		
	end

	ClosestSquad = nil
	ShortestDistance = 10000
	for i = 1, g_PlayerSquadCount[_player] do
		local DistanceToPoint = World_DistancePointToPoint(_pos, g_AllSquadsData[_player][i].SquadPosition)
		if(DistanceToPoint <= ShortestDistance and DistanceToPoint < _maxDistance) then
			print(g_AllSquadsData[_player][i].SquadBlueprint.." Is closer with distance of "..DistanceToPoint)
			ShortestDistance = DistanceToPoint
			ClosestSquad = g_AllSquadsData[_player][i].SquadPosition
		end
	end

	
	if(ClosestSquad == nil) then

		Log(1, 0, debug_SquadManager_FileName, debugFuncName, "No squads are in range of that position. You may need to increae the max distance.")

	end

	return ClosestSquad 
end

--Use for single target in given group
function GetClosestSquadInSquadTableToPos(_squads, _pos, _maxDistance)

	local debugFuncName = "GetClosestSquadInSquadTableToPos"	

	if(TableLength(_squads) == 0) then

		Log(1, 0, debug_SquadManager_FileName, debugFuncName, "No squads are near that position as player has no squads.")
		return nil
		
	end
	
	ClosestSquad = nil
	ShortestDistance = 10000
	for i = 1, TableLength(_squads) do
		local point1 = World_Pos(_squads[i].SquadPosition.x, _squads[i].SquadPosition.y, _squads[i].SquadPosition.z )
		local point2 = World_Pos(_pos.x, _pos.y, _pos.z )
		local DistanceToPoint = World_DistancePointToPoint(point1, point2)
		print(DistanceToPoint)
		if(DistanceToPoint <= ShortestDistance and DistanceToPoint < _maxDistance) then
			print(_squads[i].SquadBlueprint.." Is closer with distance of "..DistanceToPoint)
			ShortestDistance = DistanceToPoint
			ClosestSquad = _squads[i]
		end
	end

	if(ClosestSquad == nil) then

		Log(1, 0, debug_SquadManager_FileName, debugFuncName, "No squads are in range of that position. You may need to increae the max distance.")

	end

	return ClosestSquad 
end

function GetAllSquadsOfArmourType(_player, _acceptedArmourTypes)

	local debugFuncName = "GetAllSquadsOfArmourType"

	local AllSquadsOfArmourType = {}
	for i = 1, TableLength(_acceptedArmourTypes) do

		for j = 1, g_PlayerSquadCount[_player] do

			if(Squad_HasArmourType(g_AllSquadsData[_player][j].SquadID, _acceptedArmourTypes[i])) then

				table.insert(AllSquadsOfArmourType, g_AllSquadsData[_player][j])

			end

		end

	end

	if(TableLength(AllSquadsOfArmourType) == 0) then

		Log(1, 0, debug_SquadManager_FileName, debugFuncName, "No squads of the specified armour types exist.")

	end

end

function GetAllSquadsOfArmourTypeFromSquadTable(_squads, _acceptedArmourTypes)

	local debugFuncName = "GetAllSquadsOfArmourType"

	if(TableLength(_squads) == 0) then

		Log(1, 0, debug_SquadManager_FileName, debugFuncName, "_squads table is nil.")
		return nil
		
	end

	local AllSquadsOfArmourType = {}
	for i = 1, TableLength(_acceptedArmourTypes) do

		for j = 1, _squads do

			if(Squad_HasArmourType(_squads[j].SquadID, _acceptedArmourTypes[i])) then

				table.insert(AllSquadsOfArmourType, _squads[j])

			end
			
		end

	end

	if(TableLength(AllSquadsOfArmourType) == 0) then

		Log(1, 0, debug_SquadManager_FileName, debugFuncName, "No squads of the specified armour types exist.")

	end

	return AllSquadsOfArmourType

end

function GetAllSquadsOfArmourTypeFromPlayerTable(_players, _acceptedArmourTypes)

	local debugFuncName = "GetAllSquadsOfArmourTypeFromPlayerTable"

	local AllSquadsOfArmourType = {}
	for i = 1, TableLength(_acceptedArmourTypes) do
		for p = 1, TableLength(_players) do
			local pIndex = _players[p].PlayerIndex+1
			--Continue from here, the max limit in this loop is wrong ofc lol..
			for j = 1, TableLength(g_AllSquadsData[pIndex]) do
				print("Index: "..pIndex)
				if(Squad_HasArmourType(g_AllSquadsData[pIndex][j].SquadID, _acceptedArmourTypes[i])) then

					table.insert(AllSquadsOfArmourType, g_AllSquadsData[pIndex][j])

				end
				
			end
		end
	end

	if(TableLength(AllSquadsOfArmourType) == 0) then

		Log(1, 0, debug_SquadManager_FileName, debugFuncName, "No squads of the specified armour types exist.")

	end

	return AllSquadsOfArmourType

end

