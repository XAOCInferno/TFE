import("TFE_Core/CriticalScars/EntityManager/Imports/EntityManager_Imports.scar")

---------------
--Main Script--
---------------
function Setup_EntityManager()
	
	AddStacktrace("Setup_EntityManager")

	Set_AllEntities_Immediate()

	RemoveStacktrace()

end

function Set_AllEntities_Immediate()
	
	AddStacktrace("Set_AllEntities_Immediate")

	for i = 1, g_PlayerCount do
		
		Set_PlayerEntities_Immediate(i)
		
	end

	RemoveStacktrace()

end

function Set_PlayerEntities_Immediate(_PlayerIndex)	

	AddStacktrace("Set_PlayerEntities_Immediate")
	
	g_LastEntityUpdateTime = g_WorldTime
	
	local AddEGroupData = function(_egroupid, _itemindex, _entityID)
		
		AddStacktrace("AddEGroupData")

		local newEntityGameID = Entity_GetGameID( _entityID )
		local entityBP = Entity_GetBlueprintName( _entityID )			
		local addNewDataEntry = true

		--Should we keep this? are some entities ok to not have BP? unsure.
		if(entityBP == nil) then

			addNewDataEntry = false
			--any point having this log if it's LogOnce?
			LogOnce(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Can't add entity data, BP is nil!")

		elseif(TableContains(g_EntityBlueprintToIgnore, entityBP) == false) then 
		
			for l = 1, table.getn(g_AllEntityData[_PlayerIndex]) do

				if(g_AllEntityData[_PlayerIndex][l] == nil) then

					Log(eLOG_LOG_TYPE_WARNING, eLOG_VERBOSE, "Entity is found null during adding.")
					table.remove(g_AllEntityData[_PlayerIndex], l)	
					addNewDataEntry = false
					--I don't think we still need to return here?
					--return false 

				end

				--We already have a data entry for this unit
				if(g_AllEntityData[_PlayerIndex][l].EntityUniqueID == newEntityGameID) then
					
					--LogOnce(eLOG_TYPE_WARNING, eLOG_FULL, "Entity is already stored in data!")
					addNewDataEntry = false
					break
											
				end

			end	

		end	
		
		if(addNewDataEntry) then

			local IsLP = false
			local IsGen = false
			local IsThermo = false

			--Move this table into an entity table so we can find from anywhere
			if(TableContains(
				{
					"chaos_listening_post", "dark_eldar_listening_post", "eldar_listening_post", 
					"guard_listening_post", "inquisition_imperial_icon", "necron_listening_post",
					"ork_gork_totem", "sisters_listening_post", "space_marine_listening_post", 
					"space_marine_listening_post_veteran", "tau_listening_post", "tyranids_listening_post"

				}, entityBP)) then

				IsLP = true

			end
			
			--Move this table into an entity table so we can find from anywhere
			if(TableContains(
				{
					"chaos_thermo_plasma_generator", "chaos_plasma_generator", "dark_eldar_thermo_plasma", 
					"dark_eldar_plasma_generator", "eldar_advanced_warp_generator", "eldar_warp_generator", 
					"guard_thermo_plasma", "guard_plasma_generator", "inquisition_warp_reactor",
					"inquisition_warp_generator", "necron_thermoplasma_generator", "necron_plasma_generator",
					"ork_bigger_generator", "ork_generator", "sisters_thermo_plasma",
					"sisters_plasma_generator", "space_marine_thermo_generator", "space_marine_generator", 
					"space_marine_thermo_generator_veteran", "space_marine_generator_veteran", "tau_thermoplasma_generator", 
					"tau_plasma_generator", "tyranids_thermo_generator", "tyranids_generator"

				}, entityBP)) then

				IsGenerator = true

				if(TableContains(
				{
					"chaos_thermo_plasma_generator", "dark_eldar_thermo_plasma", "eldar_advanced_warp_generator", 
					"guard_thermo_plasma", "inquisition_warp_reactor", "necron_thermoplasma_generator",	
					"ork_bigger_generator", "sisters_thermo_plasma", "space_marine_thermo_generator",  
					"space_marine_thermo_generator_veteran", "tau_thermoplasma_generator", "tyranids_thermo_generator"

				}, entityBP)) then

					IsThermo = true

				end

			end

			local tmpData = EntityData:new( newEntityGameID, _egroupid, _itemindex, _entityID, g_AllPlayers[_PlayerIndex].RaceDetails.RaceName, entityBP, g_AllPlayers[_PlayerIndex], IsLP, IsGenerator, IsThermo)
			
			Log(eLOG_TYPE_INFO, eLOG_VERBOSE, "Entity data created for entity: "..tmpData.EntityBlueprint)
			table.insert(g_AllEntityData[_PlayerIndex], tmpData)

		end

		RemoveStacktrace()
			
	end

	--We should only run the Entity checker if the player is alive
	if (Player_IsAlive(g_AllPlayers[_PlayerIndex].Player)) then		

		Update_ExistingEntityDetails()		
		EGroup_ForEachEx(Player_GetEntities(g_AllPlayers[_PlayerIndex].Player), AddEGroupData, true, false)				
		
		for k = 1, TableLength(g_AllEntityData[_PlayerIndex]) do

			if(g_AllEntityData[_PlayerIndex][k] ~= nil) then
				
				local shouldIgnore, _ = TableContains(g_EntityBlueprintToIgnore, g_AllEntityData[_PlayerIndex][k].EntityBlueprint)
				--Should there be a different check for entity instead of health?

				if(g_AllEntityData[_PlayerIndex][k].EntityBlueprint == nil or g_AllEntityData[_PlayerIndex][k].EntityHealthCurrent == 0 or shouldIgnore) then

					Log(eLOG_LOG_TYPE_WARNING, eLOG_FULL, "Entity is destroyed, removing.")
					table.remove(g_AllEntityData[_PlayerIndex], k)
					
				end

			end

		end
			
		g_PlayerEntityCount[_PlayerIndex] = TableLength(g_AllEntityData[_PlayerIndex])

	end

	RemoveStacktrace()

end

function Update_ExistingEntityDetails()
	
	AddStacktrace("Update_ExistingEntityDetails")

	for i = 1, g_PlayerCount do

		for l = 1, TableLength(g_AllEntityData[i]) do

			--Simple check to avoid null ref
			if(g_AllEntityData[i][l] == nil) then
				
				Log(eLOG_LOG_TYPE_ERROR, eLOG_FULL, "Entity is nil, this should never happen.")

			else

				--Logic will run, but if there is an error (entity no longer exists) then we remove it
				if(g_AllEntityData[i][l]:Update() == false) then

					local EntityLosses = 1
					local StructureLosses =  bool_to_number(g_AllEntityData[i][l].EntityIsStructure)
					local LPLosses = bool_to_number(g_AllEntityData[i][l].EntityIsLP)
					local GenLosses = bool_to_number(g_AllEntityData[i][l].EntityIsGen)
					local ThermoLosses = bool_to_number(g_AllEntityData[i][l].EntityIsThermo)
	
					for z = 1, table.getn(g_AllEntityData[i][l].PreviouslyAttackedByPlayers) do
		
						--Again redo this so defender isn't given multiple bonuses...
						UpdateEntityCombatDeathResources(g_AllEntityData[i][l].PreviouslyAttackedByPlayers[z], g_AllEntityData[i][l].OwnerPlayer, EntityLosses, StructureLosses, LPLosses, GenLosses, ThermoLosses ) 
						UpdateEntityCombatDeathStats(g_AllEntityData[i][l].PreviouslyAttackedByPlayers[z], g_AllEntityData[i][l].OwnerPlayer, EntityLosses, StructureLosses, LPLosses, GenLosses, ThermoLosses ) 
		
					end	

					g_AllEntityData[i][l] = nil	

				end

			end

		end	

	end

	RemoveStacktrace()

end

function Get_EntityDataFromEntityBP(_EntityBP, _Player)

	AddStacktrace("Get_EntityDataFromEntityBP")

	local tbl_AllEntityOfBP = {}
	local tbl_IndexOfAcceptedPositions = {}
	for i = 1, TableLength(g_AllEntityData[_Player]) do
		
		if(g_AllEntityData[_Player][i].EntityBlueprint == _EntityBP) then
			
			table.insert(tbl_AllEntityOfBP, g_AllEntityData[_Player][i])
			table.insert(tbl_IndexOfAcceptedPositions, i)

		end

	end

	RemoveStacktrace()

	return tbl_AllEntityOfBP, tbl_IndexOfAcceptedPositions

end

function DestroyEntityAndRemoveFromData(_Player, _EntityLocation)

	AddStacktrace("DestroyEntityAndRemoveFromData")

	local PlayerIndex = _Player.PlayerIndex + 1

	if(g_AllEntityData[PlayerIndex][_EntityLocation] == nil) then

		Log(eLOG_LOG_TYPE_ERROR, eLOG_FULL, "Entity is nil, cannot destroy and returning!")

	else

		Entity_Destroy(g_AllEntityData[PlayerIndex][_EntityLocation].EntityID)
		table.remove(g_AllEntityData[PlayerIndex][_EntityLocation])
		
	end

	RemoveStacktrace()

end

function Entity_Exists(_EntityID)

	AddStacktrace("Entity_Exists")
	
	local EntityExists = false

	if Entity_GetGameID(_EntityID) ~= 0 then

		EntityExists = true
		
	end
	
	RemoveStacktrace()

	return EntityExists

end

function UpdateEntityCombatDeathResources(_RedReceiverPlayer, _DefenderPlayer, _EntityLosses, _StructureLosses, _LPLosses, _GenLosses, _ThermoLosses ) 

	AddStacktrace("UpdateEntityCombatDeathResources")

	local TotalRed = 0
	TotalRed = TotalRed + (4 * _EntityLosses)
	TotalRed = TotalRed + (15 * _StructureLosses)
	TotalRed = TotalRed + (5 * _LPLosses)
	TotalRed = TotalRed + (5 * _GenLosses)
	TotalRed = TotalRed + (15 * _ThermoLosses)
	TotalRed = TotalRed * g_RedGainMultiplier

	_RedReceiverPlayer.CurrentResources.RT_Red = _RedReceiverPlayer.CurrentResources.RT_Red + TotalRed	
	_DefenderPlayer.CurrentResources.RT_Red = _DefenderPlayer.CurrentResources.RT_Red + (TotalRed * 0.5)	

	--Debug	
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Player ".._RedReceiverPlayer.PlayerIndex.." current Red = ".._RedReceiverPlayer.CurrentResources.RT_Red)
	Log(eLOG_TYPE_INFO, eLOG_SIMPLE, "Player ".._DefenderPlayer.PlayerIndex.." current Red = ".._DefenderPlayer.CurrentResources.RT_Red)

	RemoveStacktrace()

end

function UpdateEntityCombatDeathStats(_AttackerPlayer, _DefenderPlayer, _EntityLosses, _StructureLosses, _LPLosses, _GenLosses, _ThermoLosses ) 

	AddStacktrace("UpdateEntityCombatDeathStats")

	_AttackerPlayer.StatsManager:AddEntityKills( _EntityLosses, _StructureLosses, _LPLosses, _GenLosses, _ThermoLosses )
	_DefenderPlayer.StatsManager:AddEntityLosses( _EntityLosses, _StructureLosses, _LPLosses, _GenLosses, _ThermoLosses )

	RemoveStacktrace()

end
